# Copyright 2025 Vijaykumar Singh <singhvjd@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""VerticalBase - Abstract base class for domain-specific assistants.

Implements the Template Method pattern where:
- VerticalBase defines the skeleton of creating an agent
- Concrete verticals override specific configuration steps

Design Patterns:
    - Template Method: Define skeleton, override steps
    - Factory Method: create_agent() factory
    - Registry: VerticalRegistry for discovery

Architecture (Phase 2.3 - SRP Compliance):
    VerticalBase now composes functionality from focused classes:
    - VerticalMetadataProvider: Metadata (name, description, provider hints, etc.)
    - VerticalExtensionLoader: Extension loading and caching
    - VerticalWorkflowProvider: Workflow and handler providers

YAML Configuration (NEW):
    Verticals can now define their configuration in YAML files instead of
    implementing multiple get_* methods. This reduces boilerplate by ~90%.

    YAML Configuration Priority:
        1. If vertical.yaml exists, load from YAML
        2. Otherwise, fall back to programmatic get_* methods
        3. YAML loading failures fall back to programmatic methods with a warning

    YAML File Location:
        victor/{vertical_name}/config/vertical.yaml (preferred)
        victor/{vertical_name}/vertical.yaml (fallback)

    Example YAML (victor/coding/config/vertical.yaml):
        metadata:
          name: coding
          description: Software development assistant
          version: "2.0.0"

        core:
          tools: list[Any]: [read, write, edit, code_search]
          system_prompt:
            source: inline
            text: "You are an expert software developer..."
          stages:
            INITIAL:
              name: INITIAL
              description: Understanding the request
              tools: [read, ls]
              keywords: [what, how]
              next_stages: [PLANNING]

        provider:
          hints:
            preferred: [anthropic, openai]

    Programmatic Example (Legacy):
        class MyCustomVertical(VerticalBase):
            name = "my_vertical"
            description = "Custom assistant for X"

            @classmethod
            def get_tools(cls) -> List[str]:
                return ["read", "write", "custom_tool"]

            @classmethod
            def get_system_prompt(cls) -> str:
                return "You are an expert in X..."

    Backward Compatibility:
        All existing verticals work unchanged. The programmatic get_* methods
        are used as fallback when YAML is not available. To disable YAML loading
        for a specific call, use: get_config(use_yaml=False)
"""

from __future__ import annotations

import logging
import sys
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from pathlib import Path
from typing import (
    Any,
    ClassVar,
    Dict,
    KeysView,
    List,
    Optional,
    Set,
    Type,
    TYPE_CHECKING,
    Union,
)
from typing import Protocol as TypingProtocol

from victor.framework.tools import ToolSet

# Import focused capability providers for SRP compliance
from victor.core.verticals.metadata import VerticalMetadataProvider
from victor.core.verticals.extension_loader import VerticalExtensionLoader
from victor.core.verticals.workflow_provider import VerticalWorkflowProvider

# Import protocol-based extension loader for ISP compliance
from victor.core.verticals.protocol_loader import ProtocolBasedExtensionLoader

if TYPE_CHECKING:
    from victor.core.verticals.protocols import VerticalExtensions
    from importlib.metadata import EntryPoint
    from victor.core.verticals.extension_registry import ExtensionRegistry

# Import StageDefinition from core for centralized definition
# Re-export for backward compatibility
from victor.core.vertical_types import StageDefinition

logger = logging.getLogger(__name__)


@dataclass
class VerticalConfig:
    """Configuration generated by a vertical.

    This is passed to Agent.create() to configure the agent.

    Attributes:
        name: Vertical identifier
        tools: ToolSet configuration
        system_prompt: System prompt text
        stages: Stage definitions
        provider_hints: Hints for provider selection
        evaluation_criteria: Criteria for evaluating agent performance
        metadata: Additional vertical-specific metadata
    """

    tools: ToolSet
    system_prompt: str
    name: str = ""
    stages: Dict[str, StageDefinition] = field(default_factory=dict)
    provider_hints: Dict[str, Any] = field(default_factory=dict)
    evaluation_criteria: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_agent_kwargs(self) -> Dict[str, Any]:
        """Convert to kwargs for Agent.create().

        Returns:
            Dictionary of keyword arguments.
        """
        return {
            "tools": self.tools,
            # System prompt is typically handled separately
        }

    def to_dict(self) -> Dict[str, Any]:
        """Convert config to dictionary for dict-like access.

        Returns:
            Dictionary representation of the configuration.
        """
        return {
            "name": self.name,
            "tools": self.tools.tools if self.tools else [],
            "system_prompt": self.system_prompt,
            "stages": {
                k: {"name": v.name, "description": v.description} for k, v in self.stages.items()
            },
            "provider_hints": self.provider_hints,
            "evaluation_criteria": self.evaluation_criteria,
            "metadata": self.metadata,
        }

    def keys(self) -> KeysView[str]:
        """Return keys for dict-like access compatibility.

        Returns:
            Keys iterator for dictionary representation.
        """
        return self.to_dict().keys()

    def __getitem__(self, key: str) -> Any:
        """Enable dict-like access: config["key"].

        Args:
            key: Configuration key

        Returns:
            Configuration value

        Raises:
            KeyError: If key not found
        """
        d = self.to_dict()
        if key not in d:
            raise KeyError(key)
        return d[key]

    def get(self, key: str, default: Any = None) -> Any:
        """Get config value with default, like dict.get().

        Args:
            key: Configuration key
            default: Default value if key not found

        Returns:
            Configuration value or default
        """
        try:
            return self[key]
        except KeyError:
            return default

    def __contains__(self, key: str) -> bool:
        """Enable 'in' operator: "key" in config.

        Args:
            key: Configuration key

        Returns:
            True if key exists in config
        """
        try:
            self[key]
            return True
        except KeyError:
            return False

    def __setitem__(self, key: str, value: Any) -> None:
        """Enable item assignment: config["key"] = value.

        Note: This is for compatibility with dict-like access.
        In practice, VerticalConfig is typically immutable, but this
        method is needed for MutableVerticalContext which supports
        dynamic capability application.

        Args:
            key: Configuration key
            value: Configuration value
        """
        # Store in metadata dict for dynamic keys
        if not hasattr(self, "_dynamic_values"):
            self._dynamic_values = {}
        self._dynamic_values[key] = value

    def to_dict_with_dynamic(self) -> Dict[str, Any]:
        """Convert to dictionary including dynamic values.

        Returns:
            Dictionary representation
        """
        d = {
            "tools": self.tools,
            "system_prompt": self.system_prompt,
            "stages": {
                k: {"name": v.name, "description": v.description} for k, v in self.stages.items()
            },
            "provider_hints": self.provider_hints,
            "evaluation_criteria": self.evaluation_criteria,
            "metadata": self.metadata,
        }
        # Include any dynamically set values
        if hasattr(self, "_dynamic_values"):
            d.update(self._dynamic_values)
        return d


class VerticalBase(
    VerticalMetadataProvider,
    VerticalExtensionLoader,
    VerticalWorkflowProvider,
    ABC,
):
    """Abstract base class for domain-specific assistants.

    Implements the Template Method pattern using composition of focused
    capability providers for SRP compliance:

    - VerticalMetadataProvider: Metadata (name, description, version,
      provider_hints, evaluation_criteria, capability_configs)
    - VerticalExtensionLoader: Extension loading (middleware, safety,
      prompt_contributor, mode_config, tool_deps, etc.)
    - VerticalWorkflowProvider: Workflow and handler providers

    YAML Configuration (NEW):
        Verticals can now define configuration in YAML files instead of
        implementing get_* methods. Place vertical.yaml in:
        - victor/{vertical_name}/config/vertical.yaml (preferred)
        - victor/{vertical_name}/vertical.yaml (fallback)

        YAML config is loaded automatically when available. Set use_yaml=False
        in get_config() to disable YAML loading.

    Subclasses must override:
    - name: Vertical identifier
    - description: Human-readable description
    - get_tools(): List of tool names (used as fallback if no YAML)
    - get_system_prompt(): System prompt text (used as fallback if no YAML)

    Optional overrides:
    - get_stages(): Stage definitions (used as fallback if no YAML)
    - customize_config(): Hook for final config customization
    - Extension methods: get_middleware(), get_safety_extension(), etc.

    Example (YAML-first):
        # victor/coding/config/vertical.yaml
        metadata:
          name: coding
          description: Software development assistant
        core:
          tools: list[Any]: [read, write, edit]
          system_prompt:
            source: inline
            text: "You are an expert developer..."

        # victor/coding/assistant.py
        class CodingAssistant(VerticalBase):
            name = "coding"
            # Config loaded from YAML automatically!

    Example (Legacy/Programmatic):
        class SecurityAuditor(VerticalBase):
            name = "security_auditor"
            description = "Security vulnerability analysis"

            @classmethod
            def get_tools(cls):
                return ["read", "search", "security_scan"]

            @classmethod
            def get_system_prompt(cls):
                return "You are a security expert..."

    Config Caching:
        The get_config() method caches its result per-class to avoid
        repeated computation. Call clear_config_cache() to invalidate
        when config sources change (typically only needed in tests).

    Extension Loading:
        The get_extensions() method supports strict error handling.
        Set strict_extension_loading=True to raise ExtensionLoadError on
        any failure. Set required_extensions to specify which extensions
        must load successfully even in non-strict mode.

    Backward Compatibility:
        All methods from the original VerticalBase are preserved through
        inheritance from the focused provider classes. Existing verticals
        that inherit from VerticalBase require no changes. YAML config is
        optional and programmatic get_* methods work as fallback.
    """

    # Config cache (keyed by class name, stores VerticalConfig)
    _config_cache: Dict[str, "VerticalConfig"] = {}

    # Extension registry for dynamic extension registration (OCP-compliant)
    _extension_registry: ClassVar[Optional["ExtensionRegistry"]] = None

    # =========================================================================
    # Required Abstract Methods
    # =========================================================================

    @classmethod
    @abstractmethod
    def get_tools(cls) -> List[str]:
        """Get the list of tool names for this vertical.

        Returns:
            List of tool names to enable.
        """
        pass

    @classmethod
    @abstractmethod
    def get_system_prompt(cls) -> str:
        """Get the system prompt for this vertical.

        Returns:
            System prompt text with domain expertise.
        """
        pass

    # =========================================================================
    # Configurable Override Points
    # =========================================================================

    @classmethod
    def get_stages(cls) -> Dict[str, StageDefinition]:
        """Get stage definitions for this vertical.

        Default implementation provides a comprehensive 7-stage workflow
        representing a generic problem-solving lifecycle:

        1. INITIAL: Understand the request and gather initial context
        2. PLANNING: Design the approach and strategy
        3. READING: Gather detailed information and context
        4. ANALYSIS: Analyze information and identify solutions
        5. EXECUTION: Implement the planned changes
        6. VERIFICATION: Validate results and test outcomes
        7. COMPLETION: Finalize, document, and wrap up

        This workflow applies to most domains:
        - Coding: understand -> plan -> read code -> analyze -> implement -> test -> commit
        - DevOps: assess -> plan -> implement -> validate -> deploy -> monitor
        - Research: question -> search -> read -> synthesize -> write -> verify
        - Data Analysis: understand -> explore -> analyze -> visualize -> report

        Verticals should override this method to provide domain-specific:
        - Stage names (e.g., DEPLOYMENT, SYNTHESIZING)
        - Tools appropriate for each stage
        - Domain-specific keywords

        Returns:
            Dictionary mapping stage names to StageDefinition objects.
            Each stage includes description, keywords, and valid transitions.
        """
        return {
            "INITIAL": StageDefinition(
                name="INITIAL",
                description="Understanding the request and gathering initial context",
                keywords=[
                    "what",
                    "how",
                    "explain",
                    "help",
                    "where",
                    "show me",
                    "describe",
                    "overview",
                    "understand",
                    "clarify",
                ],
                next_stages={"PLANNING", "READING"},
            ),
            "PLANNING": StageDefinition(
                name="PLANNING",
                description="Designing the approach and creating a strategy",
                keywords=[
                    "plan",
                    "approach",
                    "strategy",
                    "design",
                    "architecture",
                    "outline",
                    "steps",
                    "roadmap",
                    "how should",
                    "what's the best way",
                ],
                next_stages={"READING", "EXECUTION"},
            ),
            "READING": StageDefinition(
                name="READING",
                description="Gathering detailed information and context",
                keywords=[
                    "read",
                    "show",
                    "find",
                    "search",
                    "look",
                    "check",
                    "examine",
                    "inspect",
                    "review",
                    "fetch",
                    "get",
                    "retrieve",
                ],
                next_stages={"ANALYSIS", "EXECUTION"},
            ),
            "ANALYSIS": StageDefinition(
                name="ANALYSIS",
                description="Analyzing information and identifying solutions",
                keywords=[
                    "analyze",
                    "review",
                    "understand",
                    "why",
                    "how does",
                    "compare",
                    "evaluate",
                    "assess",
                    "investigate",
                    "diagnose",
                ],
                next_stages={"EXECUTION", "PLANNING"},
            ),
            "EXECUTION": StageDefinition(
                name="EXECUTION",
                description="Implementing the planned changes or actions",
                keywords=[
                    "change",
                    "modify",
                    "create",
                    "add",
                    "remove",
                    "fix",
                    "implement",
                    "write",
                    "update",
                    "refactor",
                    "build",
                    "configure",
                    "set up",
                    "install",
                    "run",
                    "execute",
                ],
                next_stages={"VERIFICATION", "COMPLETION"},
            ),
            "VERIFICATION": StageDefinition(
                name="VERIFICATION",
                description="Validating results and testing outcomes",
                keywords=[
                    "test",
                    "verify",
                    "check",
                    "validate",
                    "confirm",
                    "ensure",
                    "run tests",
                    "build",
                    "compile",
                    "lint",
                ],
                next_stages={"COMPLETION", "EXECUTION"},
            ),
            "COMPLETION": StageDefinition(
                name="COMPLETION",
                description="Finalizing, documenting, and wrapping up",
                keywords=[
                    "done",
                    "finish",
                    "complete",
                    "commit",
                    "summarize",
                    "document",
                    "conclude",
                    "wrap up",
                    "finalize",
                ],
                next_stages=set(),
            ),
        }

    @classmethod
    def customize_config(cls, config: VerticalConfig) -> VerticalConfig:
        """Hook for final configuration customization.

        Override to modify the config before it's returned.

        Args:
            config: Configuration to customize.

        Returns:
            Customized configuration.
        """
        return config

    # =========================================================================
    # PromptBuilder Support (Phase 7)
    # =========================================================================

    @classmethod
    def get_prompt_builder(cls) -> Any:  # No specific type to avoid circular import
        """Get configured PromptBuilder for this vertical.

        Provides a PromptBuilder instance pre-configured with vertical-specific
        content. Subclasses can override this to add custom sections while
        maintaining backward compatibility with get_system_prompt().

        Returns:
            PromptBuilder instance with vertical-specific configuration

        Example:
            builder = MyVertical.get_prompt_builder()
            builder.add_grounding("Project: {name}", name="MyProject")
            prompt = builder.build()
        """
        from victor.framework.prompt_builder import PromptBuilder

        builder = PromptBuilder()

        # Add vertical-specific section
        builder.add_vertical_section(
            vertical=cls.name,
            content=cls._get_vertical_prompt(),
            priority=40,
        )

        return builder

    @classmethod
    def _get_vertical_prompt(cls) -> str:
        """Get vertical-specific prompt content (override in subclasses).

        This method provides the core vertical-specific content that will be
        included in the prompt. Subclasses should override this to provide
        their domain-specific content.

        Returns:
            Vertical-specific prompt content

        Example:
            @classmethod
            def _get_vertical_prompt(cls):
                return \"\"\"You are an expert {vertical} assistant.

                Your capabilities:
                - Capability 1
                - Capability 2
                \"\"\".format(vertical=cls.name)
        """
        return f"You are an expert {cls.name} assistant."

    # =========================================================================
    # Template Method Implementation
    # =========================================================================

    @classmethod
    def get_config(cls, *, use_cache: bool = True, use_yaml: bool = True) -> VerticalConfig:
        """Get the complete configuration for this vertical.

        This is the main template method that assembles the configuration
        by calling the various override points.

        YAML Configuration Priority:
            1. If use_yaml=True and vertical.yaml exists, load from YAML
            2. Otherwise, fall back to programmatic get_* methods
            3. YAML loading failures fall back to programmatic methods with a warning

        Args:
            use_cache: If True (default), return cached config if available.
                       Set to False to force rebuild.
            use_yaml: If True (default), attempt to load config from YAML file.
                     Set to False to skip YAML and use programmatic methods only.

        Returns:
            Complete VerticalConfig for agent creation.
        """
        cache_key = cls.__name__

        # Return cached config if available and caching enabled
        if use_cache and cache_key in cls._config_cache:
            return cls._config_cache[cache_key]

        # Try YAML configuration first (if enabled)
        config = None
        if use_yaml:
            config = cls._load_config_from_yaml()

        # Fallback to programmatic methods
        if config is None:
            config = cls._build_config_from_methods()

        # Allow final customization
        config = cls.customize_config(config)

        # Cache the config
        cls._config_cache[cache_key] = config
        return config

    @classmethod
    def _get_yaml_config_path(cls) -> Optional[Path]:
        """Get the path to the YAML configuration file for this vertical.

        Searches for vertical.yaml in the following locations:
        1. victor/{vertical_name}/config/vertical.yaml (preferred)
        2. victor/{vertical_name}/vertical.yaml (fallback)

        Returns:
            Path to YAML file if found, None otherwise
        """
        from pathlib import Path

        # Try to find the module's directory
        module_dir = None

        # Method 1: Try using __file__ from the module
        try:
            module = sys.modules.get(cls.__module__)
            if module and hasattr(module, "__file__") and module.__file__:
                module_file = module.__file__
                module_dir = Path(module_file).parent
        except (AttributeError, KeyError, TypeError):
            pass

        # Method 2: Try using the class's module path string
        if module_dir is None or not module_dir.exists():
            # Convert module path to file path (e.g., victor.coding -> victor/coding)
            module_path_str = cls.__module__.replace(".", "/")
            module_dir = Path(module_path_str)

        # Check for config/vertical.yaml (preferred location)
        yaml_path = module_dir / "config" / "vertical.yaml"
        if yaml_path.exists():
            return yaml_path

        # Check for vertical.yaml in vertical root (fallback)
        yaml_path = module_dir / "vertical.yaml"
        if yaml_path.exists():
            return yaml_path

        return None

    @classmethod
    def _load_config_from_yaml(cls) -> Optional[VerticalConfig]:
        """Load configuration from YAML file.

        Attempts to load vertical.yaml for this vertical. If loading fails
        for any reason, returns None and logs a warning.

        Returns:
            VerticalConfig if YAML loaded successfully, None otherwise
        """
        yaml_path = cls._get_yaml_config_path()
        if yaml_path is None:
            return None

        try:
            from victor.core.verticals.config import VerticalConfigLoader

            loader = VerticalConfigLoader()
            config = loader.load_from_yaml(yaml_path)

            if config is not None:
                logger.info(f"Loaded YAML config for {cls.name} from {yaml_path}")
                return config
            else:
                logger.warning(f"Failed to load YAML config from {yaml_path}")
                return None

        except Exception as e:
            logger.warning(
                f"Error loading YAML config for {cls.name} from {yaml_path}: {e}. "
                f"Falling back to programmatic methods."
            )
            return None

    @classmethod
    def _build_config_from_methods(cls) -> VerticalConfig:
        """Build configuration from programmatic get_* methods.

        This is the legacy approach that calls the various get_* methods
        to build the configuration.

        Returns:
            VerticalConfig built from programmatic methods
        """
        # Build tool set
        tool_names = cls.get_tools()
        tools = ToolSet.from_tools(tool_names)

        # Build config
        return VerticalConfig(
            name=cls.name,
            tools=tools,
            system_prompt=cls.get_system_prompt(),
            stages=cls.get_stages(),
            provider_hints=cls.get_provider_hints(),
            evaluation_criteria=cls.get_evaluation_criteria(),
            metadata={
                "vertical_name": cls.name,
                "vertical_version": cls.version,
                "description": cls.description,
            },
        )

    @classmethod
    def clear_config_cache(cls, *, clear_all: bool = False) -> None:
        """Clear the config cache for this vertical.

        Also clears individual extension cache entries created by
        _get_cached_extension() for this class.

        Args:
            clear_all: If True, clear cache for all verticals.
                       If False (default), clear only for this class.
        """
        if clear_all:
            cls._config_cache.clear()
            cls.clear_extension_cache(clear_all=True)
        else:
            cache_key = cls.__name__
            cls._config_cache.pop(cache_key, None)
            # Clear extensions cache for this class too
            cls.clear_extension_cache(clear_all=False)

    # =========================================================================
    # ISP Compliance: Protocol Conformance Methods
    # =========================================================================

    @classmethod
    def implements_protocol(cls, protocol_type: Type[Any]) -> bool:
        """Check if this vertical implements a specific protocol.

        This method provides ISP-compliant protocol checking, allowing verticals
        to declare which protocols they implement without needing to inherit
        from all possible protocol classes.

        Args:
            protocol_type: The protocol class to check (e.g., ToolProvider,
                          PromptProviderProtocol, SafetyProvider)

        Returns:
            True if this vertical implements the protocol, False otherwise

        Example:
            from victor.core.verticals.protocols.providers import ToolProvider

            if MyVertical.implements_protocol(ToolProvider):
                print("MyVertical implements ToolProvider protocol")
        """
        return ProtocolBasedExtensionLoader.implements_protocol(cls, protocol_type)

    @classmethod
    def register_protocol(cls, protocol_type: Type[Any]) -> None:
        """Register this vertical as implementing a protocol.

        This method allows verticals to explicitly declare protocol conformance,
        enabling isinstance() checks by the framework.

        Args:
            protocol_type: The protocol class to register (e.g., ToolProvider,
                          PromptProviderProtocol)

        Example:
            from victor.core.verticals.protocols.providers import ToolProvider

            class MyVertical(VerticalBase):
                name = "my_vertical"

                @classmethod
                def __init_subclass__(cls, **kwargs):
                    super().__init_subclass__(**kwargs)
                    cls.register_protocol(ToolProvider)
        """
        ProtocolBasedExtensionLoader.register_protocol(protocol_type, cls)

    @classmethod
    def list_implemented_protocols(cls) -> List[Type[Any]]:
        """List all protocols explicitly implemented by this vertical.

        Returns:
            List of protocol types implemented by this vertical

        Example:
            protocols = MyVertical.list_implemented_protocols()
            # [ToolProvider, PromptProviderProtocol, ...]
        """
        return ProtocolBasedExtensionLoader.list_protocols(cls)

    # =========================================================================
    # Dynamic Extension Registry Integration (OCP-Compliant)
    # =========================================================================

    @classmethod
    def _get_extension_registry(cls) -> "ExtensionRegistry":
        """Get or create the shared extension registry.

        Returns:
            ExtensionRegistry instance for dynamic extension registration
        """
        from victor.core.verticals.extension_registry import ExtensionRegistry

        if cls._extension_registry is None:
            cls._extension_registry = ExtensionRegistry()
        return cls._extension_registry

    @classmethod
    def register_extension(cls, extension: Any) -> None:
        """Register a dynamic extension for this vertical.

        Enables OCP compliance by allowing new extension types without
        modifying core code.

        Args:
            extension: Extension object implementing IExtension protocol

        Raises:
            TypeError: If extension doesn't implement IExtension protocol
            ValueError: If extension already registered

        Example:
            from dataclasses import dataclass

            @dataclass
            class AnalyticsExtension:
                extension_type: ClassVar[str] = "analytics"
                name: str
                api_key: str

                def validate(self) -> bool:
                    return bool(self.api_key)

                def get_metadata(self) -> Dict[str, Any]:
                    return {"version": "0.5.0"}

            # Register dynamically
            MyVertical.register_extension(
                AnalyticsExtension(name="my_analytics", api_key="key123")
            )
        """
        from victor.core.verticals.protocols import IExtension

        # Validate extension implements protocol
        if not isinstance(extension, IExtension):
            raise TypeError(
                f"Extension must implement IExtension protocol, " f"got {type(extension).__name__}"
            )

        # Register with shared registry
        registry = cls._get_extension_registry()
        registry.register_extension(extension)

    @classmethod
    def get_extensions_by_type(cls, extension_type: str) -> List[Any]:
        """Get all registered extensions of a specific type.

        Retrieves dynamic extensions from the registry, enabling OCP
        compliance by supporting unlimited extension types.

        Args:
            extension_type: Type of extension to retrieve (e.g., "analytics",
                          "tools", "middleware")

        Returns:
            List of extensions of the specified type (empty list if none)

        Example:
            # Get all analytics extensions
            analytics_exts = MyVertical.get_extensions_by_type("analytics")

            # Get all middleware extensions
            middleware = MyVertical.get_extensions_by_type("middleware")
        """
        registry = cls._get_extension_registry()
        return registry.get_extensions_by_type(extension_type)

    @classmethod
    def get_tool_set(cls) -> ToolSet:
        """Get the ToolSet for this vertical.

        Convenience method that returns just the tool configuration.

        Returns:
            Configured ToolSet.
        """
        return ToolSet.from_tools(cls.get_tools())

    # =========================================================================
    # Mode Configuration (Canonical - using ModeConfigRegistry)
    # =========================================================================

    @classmethod
    def get_mode_config(cls, mode_name: str) -> Any:  # type: ignore[override]  # AgentMode
        """Get mode configuration from centralized registry.

        This replaces the legacy get_mode_config() method with a canonical
        implementation that uses the ModeConfigRegistry for data-driven
        configuration.

        Args:
            mode_name: Name of the mode (e.g., "build", "plan", "explore")

        Returns:
            AgentMode instance with mode configuration

        Example:
            mode = CodingVertical.get_mode_config("plan")
            print(mode.exploration)  # ExplorationLevel.THOROUGH
            print(mode.tool_budget_multiplier)  # 2.5
        """
        from victor.core.config import ModeConfigRegistry

        registry = ModeConfigRegistry.get_instance()
        return registry.get_mode(cls.name, mode_name)

    @classmethod
    def list_modes(cls) -> List[str]:
        """List available modes for this vertical.

        Returns:
            List of mode names available for this vertical.

        Example:
            modes = CodingVertical.list_modes()
            # ["build", "plan", "explore"]
        """
        from victor.core.config import ModeConfigRegistry

        registry = ModeConfigRegistry.get_instance()
        return registry.list_modes(cls.name)

    # =========================================================================
    # RL Configuration (Canonical - using RLConfigRegistry)
    # =========================================================================

    @classmethod
    def get_rl_config(cls) -> Any:  # RLConfig
        """Get RL configuration from centralized registry.

        This provides data-driven RL configuration that complements the
        existing BaseRLConfig pattern. Verticals can use either or both.

        Returns:
            RLConfig instance with RL configuration

        Example:
            rl_config = CodingVertical.get_rl_config()
            tools = rl_config.get_tools_for_task("debugging")
            threshold = rl_config.get_quality_threshold("debugging")
        """
        from victor.core.config import RLConfigRegistry

        registry = RLConfigRegistry.get_instance()
        return registry.get_rl_config(cls.name)

    # =========================================================================
    # Capability Configuration (Canonical - using CapabilityConfigRegistry)
    # =========================================================================

    @classmethod
    def get_capabilities(cls) -> Any:  # VerticalCapabilities
        """Get capability configurations from centralized registry.

        This provides data-driven capability configuration that complements
        the existing BaseCapabilityProvider pattern.

        Returns:
            VerticalCapabilities instance with capability configurations

        Example:
            caps = CodingVertical.get_capabilities()
            for cap in caps.capabilities:
                print(f"{cap.name}: {cap.description}")
                handler = cap.import_handler()
                if handler:
                    handler(orchestrator, **cap.default_config)
        """
        from victor.core.config import CapabilityConfigRegistry

        registry = CapabilityConfigRegistry.get_instance()
        return registry.get_capabilities(cls.name)

    @classmethod
    def list_capability_names(cls) -> List[str]:
        """List available capability names for this vertical.

        Returns:
            List of capability names available for this vertical.
        """
        caps = cls.get_capabilities()
        return caps.list_capabilities()  # type: ignore[no-any-return]

    # =========================================================================
    # Capability Provider (Canonical - using CapabilityLoader)
    # =========================================================================

    @classmethod
    def get_capability_provider(cls) -> Any:  # CapabilitySet
        """Get capability provider for this vertical.

        This provides access to the centralized CapabilityLoader with YAML-based
        configuration, replacing scattered capability definitions.

        Returns:
            CapabilitySet instance with all capabilities for this vertical

        Example:
            provider = CodingVertical.get_capability_provider()
            capabilities = provider.list_capabilities(CapabilityType.TOOL)
            code_review = provider.get_capability("code_review")
        """
        from victor.core.capabilities import CapabilityLoader

        loader = CapabilityLoader.from_vertical(cls.name)
        return loader.get_capability_set(cls.name)

    @classmethod
    def list_capabilities_by_type(cls, capability_type: str | None = None) -> List[str]:
        """List capabilities by type.

        Args:
            capability_type: Filter by type (tool, workflow, middleware, etc.)

        Returns:
            List of capability names

        Example:
            tools = CodingVertical.list_capabilities_by_type("tool")
            workflows = CodingVertical.list_capabilities_by_type("workflow")
        """
        from victor.core.capabilities import CapabilityLoader

        loader = CapabilityLoader.from_vertical(cls.name)
        return loader.list_capabilities(cls.name, capability_type)

    # =========================================================================
    # Team Provider (Canonical - using BaseYAMLTeamProvider)
    # =========================================================================

    @classmethod
    def get_team_provider(cls) -> Any:  # BaseYAMLTeamProvider
        """Get team provider for this vertical.

        This provides access to the centralized BaseYAMLTeamProvider with
        YAML-based team formations, replacing scattered team definitions.

        Returns:
            BaseYAMLTeamProvider instance for this vertical

        Example:
            provider = CodingVertical.get_team_provider()
            teams = provider.list_teams()
            review_team = provider.get_team("code_review_team")
        """
        from victor.core.teams.base_provider import BaseYAMLTeamProvider

        return BaseYAMLTeamProvider.get_provider(cls.name)

    @classmethod
    def get_team(cls, team_name: str) -> Any:  # TeamSpecification | None
        """Get specific team specification.

        Args:
            team_name: Name of the team

        Returns:
            TeamSpecification instance or None

        Example:
            team = CodingVertical.get_team("code_review_team")
            print(team.formation)
            print(team.list_roles())
        """
        provider = cls.get_team_provider()
        return provider.get_team(team_name)

    @classmethod
    def list_teams(cls) -> List[str]:
        """List available teams for this vertical.

        Returns:
            List of team names

        Example:
            teams = CodingVertical.list_teams()
            # ["code_review_team", "feature_implementation_team"]
        """
        provider = cls.get_team_provider()
        return provider.list_teams()  # type: ignore[no-any-return]

    @classmethod
    async def create_agent(
        cls,
        provider: str = "anthropic",
        model: Optional[str] = None,
        **kwargs: Any,
    ) -> Any:
        """Factory method to create an agent with this vertical's config.

        Args:
            provider: LLM provider name.
            model: Optional model identifier.
            **kwargs: Additional arguments passed to Agent.create().

        Returns:
            Configured Agent instance.
        """
        from victor.framework.agent import Agent

        config = cls.get_config()
        agent_kwargs = config.to_agent_kwargs()
        agent_kwargs.update(kwargs)

        return await Agent.create(
            provider=provider,
            model=model,
            **agent_kwargs,
        )


class VerticalRegistry:
    """Registry for discovering and accessing verticals.

    Implements the Registry pattern for vertical discovery.

    Supports both built-in verticals and external verticals installed as
    pip packages via entry_points. External packages can register verticals
    using the 'victor.verticals' entry point group.

    Example:
        # Register a vertical
        VerticalRegistry.register(MyVertical)

        # List available verticals
        for name, vertical in VerticalRegistry.list_all():
            print(f"{name}: {vertical.description}")

        # Get a specific vertical
        coding = VerticalRegistry.get("coding")

    Entry Point Format (for external packages):
        # In external package's pyproject.toml
        [project.entry-points."victor.verticals"]
        security = "victor_security:SecurityAssistant"
    """

    _registry: Dict[str, Type[VerticalBase]] = {}
    _lazy_imports: Dict[str, str] = {}  # Map of vertical_name -> import_path
    _external_discovered: bool = False
    ENTRY_POINT_GROUP: str = "victor.verticals"

    @classmethod
    def register_lazy_import(cls, name: str, import_path: str) -> None:
        """Register a lazy import hook for a vertical.

        The vertical will be imported on-demand when first accessed via get().

        Args:
            name: Vertical name (e.g., "coding", "rag")
            import_path: Import path in format "module.path:ClassName"
        """
        from victor.core.verticals.naming import normalize_vertical_name

        cls._lazy_imports[normalize_vertical_name(name)] = import_path

    @classmethod
    def register(cls, vertical: Type[VerticalBase]) -> None:
        """Register a vertical.

        Args:
            vertical: Vertical class to register.

        Raises:
            ValueError: If vertical has no name.
        """
        if not vertical.name:
            raise ValueError(f"Vertical {vertical.__name__} has no name defined")
        from victor.core.verticals.naming import normalize_vertical_name

        cls._registry[normalize_vertical_name(vertical.name)] = vertical

    @classmethod
    def unregister(cls, name: str) -> None:
        """Unregister a vertical.

        Args:
            name: Vertical name to unregister.
        """
        from victor.core.verticals.naming import normalize_vertical_name

        normalized = normalize_vertical_name(name)
        if normalized in cls._registry:
            del cls._registry[normalized]

    @classmethod
    def get(cls, name: str) -> Optional[Type[VerticalBase]]:
        """Get a vertical by name.

        Args:
            name: Vertical name.

        Returns:
            Vertical class or None if not found.
        """
        from victor.core.verticals.naming import normalize_vertical_name

        name = normalize_vertical_name(name)
        # Check if already registered
        if name in cls._registry:
            return cls._registry[name]

        # Check if there's a lazy import hook
        if name in cls._lazy_imports:
            import_path = cls._lazy_imports[name]
            try:
                module_path, class_name = import_path.split(":")
                from importlib import import_module

                module = import_module(module_path)
                vertical_class_any = getattr(module, class_name)

                # Validate it's actually a VerticalBase subclass
                if not isinstance(vertical_class_any, type):
                    return None

                vertical_class: Optional[Type[VerticalBase]] = vertical_class_any
                if vertical_class is None or not issubclass(vertical_class, VerticalBase):
                    return None

                # Register it now that it's loaded
                cls.register(vertical_class)

                return vertical_class
            except Exception as e:
                import logging

                logger = logging.getLogger(__name__)
                logger.warning(f"Failed to load lazy vertical '{name}': {e}")
                # Remove failed lazy import to avoid repeated attempts
                del cls._lazy_imports[name]
                return None

        return None

    @classmethod
    def list_all(cls) -> List[tuple[str, Type[VerticalBase]]]:
        """List all registered verticals.

        Returns:
            List of (name, vertical_class) tuples.
        """
        for name in list(cls._lazy_imports.keys()):
            if name not in cls._registry:
                cls.get(name)
        return list(cls._registry.items())

    @classmethod
    def list_names(cls) -> List[str]:
        """List all registered vertical names.

        Returns:
            List of vertical names.
        """
        names = set(cls._registry.keys())
        names.update(cls._lazy_imports.keys())
        return list(names)

    @classmethod
    def clear(cls, *, reregister_builtins: bool = True) -> None:
        """Clear all registered verticals (for testing).

        Args:
            reregister_builtins: If True (default), re-register built-in verticals
                after clearing. This prevents test pollution where clearing in one
                test affects other tests that expect built-ins to be available.
        """
        cls._registry.clear()
        cls._lazy_imports.clear()
        cls._external_discovered = False

        if reregister_builtins:
            # Re-register built-in verticals to prevent test pollution
            from victor.core.verticals import _register_and_discover_verticals

            _register_and_discover_verticals()

    @classmethod
    def discover_external_verticals(cls) -> Dict[str, Type[VerticalBase]]:
        """Discover and register external verticals from entry points.

        Scans installed packages for the 'victor.verticals' entry point group
        and registers any valid vertical classes found. External verticals must:
        - Inherit from VerticalBase
        - Have a non-empty 'name' attribute

        Returns:
            Dictionary of newly discovered vertical names to their classes.

        Example entry point in external package's pyproject.toml:
            [project.entry-points."victor.verticals"]
            security = "victor_security:SecurityAssistant"

        This would load SecurityAssistant from the victor_security package
        and register it if it's a valid VerticalBase subclass.
        """
        import logging
        from importlib.metadata import entry_points

        logger = logging.getLogger(__name__)
        discovered: Dict[str, Type[VerticalBase]] = {}

        # Avoid re-discovery on repeated calls
        if cls._external_discovered:
            return discovered

        try:
            # Python 3.10+ API: entry_points() returns a SelectableGroups object
            # Use group parameter for filtering
            eps = entry_points(group=cls.ENTRY_POINT_GROUP)
        except TypeError:
            # Fallback for older Python versions (shouldn't happen with Python 3.10+)
            all_eps = entry_points()
            # Type ignore for compatibility with different importlib.metadata versions
            eps_list: Any = all_eps.get(cls.ENTRY_POINT_GROUP, [])
            eps = eps_list if isinstance(eps_list, list) else list(eps_list)  # type: ignore[assignment]

        for ep in eps:
            try:
                # Load the entry point (imports the module and gets the object)
                vertical_class = ep.load()

                # Validate that it's a proper VerticalBase subclass
                if not cls._validate_external_vertical(vertical_class, ep.name):
                    continue

                # Check for name conflicts with existing verticals
                if vertical_class.name in cls._registry:
                    existing = cls._registry[vertical_class.name]
                    logger.warning(
                        f"External vertical '{ep.name}' has name '{vertical_class.name}' "
                        f"which conflicts with existing vertical {existing.__name__}. "
                        f"Skipping registration."
                    )
                    continue

                # Register the vertical
                cls.register(vertical_class)
                discovered[vertical_class.name] = vertical_class
                logger.info(
                    f"Discovered external vertical: {vertical_class.name} " f"(from {ep.value})"
                )

            except Exception as e:
                # Log the error but continue with other entry points
                logger.warning(
                    f"Failed to load external vertical '{ep.name}' from "
                    f"entry point '{ep.value}': {e}"
                )
                continue

        cls._external_discovered = True

        if discovered:
            logger.info(
                f"Discovered {len(discovered)} external vertical(s): "
                f"{', '.join(discovered.keys())}"
            )

        return discovered

    @classmethod
    def _validate_external_vertical(
        cls,
        vertical_class: Any,
        entry_point_name: str,
    ) -> bool:
        """Validate that an external vertical class is properly implemented.

        Args:
            vertical_class: The class loaded from the entry point.
            entry_point_name: Name of the entry point (for error messages).

        Returns:
            True if the vertical is valid, False otherwise.
        """
        import logging

        logger = logging.getLogger(__name__)

        # Check if it's a class
        if not isinstance(vertical_class, type):
            logger.warning(
                f"External vertical '{entry_point_name}' is not a class "
                f"(got {type(vertical_class).__name__}). Skipping."
            )
            return False

        # Check if it inherits from VerticalBase
        if not issubclass(vertical_class, VerticalBase):
            logger.warning(
                f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                f"does not inherit from VerticalBase. Skipping."
            )
            return False

        # Check if it has a name defined
        if not getattr(vertical_class, "name", None):
            logger.warning(
                f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                f"has no 'name' attribute defined. Skipping."
            )
            return False

        # Check if abstract methods are implemented
        # VerticalBase requires get_tools() and get_system_prompt()
        try:
            # Try to call the abstract methods to ensure they're implemented
            # These are classmethods so we can call them on the class
            tools = vertical_class.get_tools()
            if not isinstance(tools, list):
                logger.warning(
                    f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                    f"get_tools() must return a list. Skipping."
                )
                return False

            prompt = vertical_class.get_system_prompt()
            if not isinstance(prompt, str):
                logger.warning(
                    f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                    f"get_system_prompt() must return a string. Skipping."
                )
                return False
        except NotImplementedError:
            logger.warning(
                f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                f"has unimplemented abstract methods. Skipping."
            )
            return False
        except Exception as e:
            logger.warning(
                f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                f"failed validation: {e}. Skipping."
            )
            return False

        return True

    @classmethod
    def reset_discovery(cls) -> None:
        """Reset the external discovery flag (for testing).

        This allows discover_external_verticals() to run again.
        """
        cls._external_discovered = False
