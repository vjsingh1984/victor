# Copyright 2025 Vijaykumar Singh <singhvjd@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""VerticalBase - Abstract base class for domain-specific assistants.

Implements the Template Method pattern where:
- VerticalBase defines the skeleton of creating an agent
- Concrete verticals override specific configuration steps

Design Patterns:
    - Template Method: Define skeleton, override steps
    - Factory Method: create_agent() factory
    - Registry: VerticalRegistry for discovery

Example:
    class MyCustomVertical(VerticalBase):
        name = "my_vertical"
        description = "Custom assistant for X"

        @classmethod
        def get_tools(cls) -> List[str]:
            return ["read", "write", "custom_tool"]

        @classmethod
        def get_system_prompt(cls) -> str:
            return "You are an expert in X..."
"""

from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any, ClassVar, Dict, List, Literal, Optional, Set, Type, TYPE_CHECKING

from victor.framework.tools import ToolSet

if TYPE_CHECKING:
    from victor.core.verticals.protocols import VerticalExtensions
    from victor.core.vertical_types import TieredToolConfig

# Import StageDefinition from core for centralized definition
# Re-export for backward compatibility
from victor.core.vertical_types import StageDefinition

logger = logging.getLogger(__name__)


@dataclass
class VerticalConfig:
    """Configuration generated by a vertical.

    This is passed to Agent.create() to configure the agent.

    Attributes:
        tools: ToolSet configuration
        system_prompt: System prompt text
        stages: Stage definitions
        provider_hints: Hints for provider selection
        evaluation_criteria: Criteria for evaluating agent performance
        metadata: Additional vertical-specific metadata
    """

    tools: ToolSet
    system_prompt: str
    stages: Dict[str, StageDefinition] = field(default_factory=dict)
    provider_hints: Dict[str, Any] = field(default_factory=dict)
    evaluation_criteria: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_agent_kwargs(self) -> Dict[str, Any]:
        """Convert to kwargs for Agent.create().

        Returns:
            Dictionary of keyword arguments.
        """
        return {
            "tools": self.tools,
            # System prompt is typically handled separately
        }

    def to_dict(self) -> Dict[str, Any]:
        """Convert config to dictionary for dict-like access.

        Returns:
            Dictionary representation of the configuration.
        """
        return {
            "tools": self.tools.tools if self.tools else [],
            "system_prompt": self.system_prompt,
            "stages": {
                k: {"name": v.name, "description": v.description} for k, v in self.stages.items()
            },
            "provider_hints": self.provider_hints,
            "evaluation_criteria": self.evaluation_criteria,
            "metadata": self.metadata,
        }

    def keys(self):
        """Return keys for dict-like access compatibility.

        Returns:
            Keys iterator for dictionary representation.
        """
        return self.to_dict().keys()

    def __getitem__(self, key: str) -> Any:
        """Enable dict-like access: config["key"].

        Args:
            key: Configuration key

        Returns:
            Configuration value

        Raises:
            KeyError: If key not found
        """
        d = self.to_dict()
        if key not in d:
            raise KeyError(key)
        return d[key]

    def get(self, key: str, default: Any = None) -> Any:
        """Get config value with default, like dict.get().

        Args:
            key: Configuration key
            default: Default value if key not found

        Returns:
            Configuration value or default
        """
        try:
            return self[key]
        except KeyError:
            return default


class VerticalBase(ABC):
    """Abstract base class for domain-specific assistants.

    Implements the Template Method pattern. Subclasses must override:
    - name: Vertical identifier
    - description: Human-readable description
    - get_tools(): List of tool names
    - get_system_prompt(): System prompt text

    Optional overrides:
    - get_stages(): Stage definitions
    - get_provider_hints(): Provider selection hints
    - get_evaluation_criteria(): Performance criteria
    - customize_config(): Hook for final config customization

    Example:
        class SecurityAuditor(VerticalBase):
            name = "security_auditor"
            description = "Security vulnerability analysis"

            @classmethod
            def get_tools(cls):
                return ["read", "search", "security_scan"]

            @classmethod
            def get_system_prompt(cls):
                return "You are a security expert..."

    Config Caching:
        The get_config() method caches its result per-class to avoid
        repeated computation. Call clear_config_cache() to invalidate
        when config sources change (typically only needed in tests).

    Extension Loading:
        The get_extensions() method now supports strict error handling.
        Set strict_extension_loading=True to raise ExtensionLoadError on
        any failure. Set required_extensions to specify which extensions
        must load successfully even in non-strict mode.
    """

    # Subclasses must define these
    name: str = ""
    description: str = ""
    version: str = "1.0.0"

    # Extension loading configuration
    # When True, any extension loading failure raises ExtensionLoadError
    strict_extension_loading: ClassVar[bool] = False

    # Extensions that must load successfully even when strict_extension_loading=False
    # Valid values: "middleware", "safety", "prompt", "mode_config", "tool_deps",
    #               "workflow", "service", "rl_config", "team_spec", "enrichment",
    #               "tiered_tools"
    required_extensions: ClassVar[Set[str]] = set()

    # Config cache (keyed by class name, stores VerticalConfig)
    _config_cache: Dict[str, "VerticalConfig"] = {}
    _extensions_cache: Dict[str, Any] = {}

    # =========================================================================
    # Extension Caching Infrastructure
    # =========================================================================

    @classmethod
    def _get_cached_extension(cls, key: str, factory: callable) -> Any:
        """Get extension from cache or create and cache it.

        This helper enables fine-grained caching of individual extension
        instances, avoiding repeated object creation when extensions are
        accessed multiple times.

        The cache uses a composite key of (class_name, extension_key) to
        ensure proper isolation between different vertical subclasses.

        Args:
            key: Unique key for this extension type (e.g., "middleware",
                 "safety_extension", "workflow_provider")
            factory: Zero-argument callable that creates the extension instance.
                     Only called if the extension is not already cached.

        Returns:
            Cached or newly created extension instance.

        Example:
            @classmethod
            def get_middleware(cls) -> List[MiddlewareProtocol]:
                def _create():
                    from myvertical.middleware import MyMiddleware
                    return [MyMiddleware()]
                return cls._get_cached_extension("middleware", _create)
        """
        # Use composite key to avoid collisions between different vertical classes
        cache_key = f"{cls.__name__}:{key}"
        if cache_key not in cls._extensions_cache:
            cls._extensions_cache[cache_key] = factory()
        return cls._extensions_cache[cache_key]

    @classmethod
    def _get_extension_factory(
        cls,
        extension_key: str,
        import_path: str,
        attribute_name: Optional[str] = None,
    ) -> Any:
        """Generic factory for lazy-loading and caching extensions.

        Eliminates boilerplate across all verticals by providing a single
        implementation of the lazy import + create + cache pattern.

        Args:
            extension_key: Cache key (e.g., "safety_extension", "prompt_contributor")
            import_path: Full Python import path (e.g., "victor.coding.safety")
            attribute_name: Class name to import. If None, auto-generates from vertical name
                          (e.g., "CodingSafetyExtension" for CodingAssistant)

        Returns:
            Cached or newly created extension instance

        Example:
            # Before (13 lines)
            def get_safety_extension(cls):
                def _create():
                    from victor.coding.safety import CodingSafetyExtension
                    return CodingSafetyExtension()
                return cls._get_cached_extension("safety_extension", _create)

            # After (3 lines)
            def get_safety_extension(cls):
                return cls._get_extension_factory(
                    "safety_extension",
                    "victor.coding.safety",
                )
        """
        def _create():
            # Determine the class name to import
            if attribute_name is None:
                # Auto-generate class name
                # Convert "CodingAssistant" → "Coding"
                vertical_name = cls.__name__.replace("Assistant", "")
                # Convert "safety_extension" → "SafetyExtension"
                extension_type = (
                    extension_key.replace("_", " ").title().replace(" ", "")
                )
                class_name = f"{vertical_name}{extension_type}"
            else:
                class_name = attribute_name

            # Lazy import: only loads module when first called
            module = __import__(import_path, fromlist=[class_name])

            # Import and instantiate
            return getattr(module, class_name)()

        # Use existing caching infrastructure
        return cls._get_cached_extension(extension_key, _create)

    @classmethod
    @abstractmethod
    def get_tools(cls) -> List[str]:
        """Get the list of tool names for this vertical.

        Returns:
            List of tool names to enable.
        """
        pass

    @classmethod
    @abstractmethod
    def get_system_prompt(cls) -> str:
        """Get the system prompt for this vertical.

        Returns:
            System prompt text with domain expertise.
        """
        pass

    @classmethod
    def get_stages(cls) -> Dict[str, StageDefinition]:
        """Get stage definitions for this vertical.

        Default implementation provides a comprehensive 7-stage workflow
        representing a generic problem-solving lifecycle:

        1. INITIAL: Understand the request and gather initial context
        2. PLANNING: Design the approach and strategy
        3. READING: Gather detailed information and context
        4. ANALYSIS: Analyze information and identify solutions
        5. EXECUTION: Implement the planned changes
        6. VERIFICATION: Validate results and test outcomes
        7. COMPLETION: Finalize, document, and wrap up

        This workflow applies to most domains:
        - Coding: understand → plan → read code → analyze → implement → test → commit
        - DevOps: assess → plan → implement → validate → deploy → monitor
        - Research: question → search → read → synthesize → write → verify
        - Data Analysis: understand → explore → analyze → visualize → report

        Verticals should override this method to provide domain-specific:
        - Stage names (e.g., DEPLOYMENT, SYNTHESIZING)
        - Tools appropriate for each stage
        - Domain-specific keywords

        Returns:
            Dictionary mapping stage names to StageDefinition objects.
            Each stage includes description, keywords, and valid transitions.
        """
        return {
            "INITIAL": StageDefinition(
                name="INITIAL",
                description="Understanding the request and gathering initial context",
                keywords=[
                    "what",
                    "how",
                    "explain",
                    "help",
                    "where",
                    "show me",
                    "describe",
                    "overview",
                    "understand",
                    "clarify",
                ],
                next_stages={"PLANNING", "READING"},
            ),
            "PLANNING": StageDefinition(
                name="PLANNING",
                description="Designing the approach and creating a strategy",
                keywords=[
                    "plan",
                    "approach",
                    "strategy",
                    "design",
                    "architecture",
                    "outline",
                    "steps",
                    "roadmap",
                    "how should",
                    "what's the best way",
                ],
                next_stages={"READING", "EXECUTION"},
            ),
            "READING": StageDefinition(
                name="READING",
                description="Gathering detailed information and context",
                keywords=[
                    "read",
                    "show",
                    "find",
                    "search",
                    "look",
                    "check",
                    "examine",
                    "inspect",
                    "review",
                    "fetch",
                    "get",
                    "retrieve",
                ],
                next_stages={"ANALYSIS", "EXECUTION"},
            ),
            "ANALYSIS": StageDefinition(
                name="ANALYSIS",
                description="Analyzing information and identifying solutions",
                keywords=[
                    "analyze",
                    "review",
                    "understand",
                    "why",
                    "how does",
                    "compare",
                    "evaluate",
                    "assess",
                    "investigate",
                    "diagnose",
                ],
                next_stages={"EXECUTION", "PLANNING"},
            ),
            "EXECUTION": StageDefinition(
                name="EXECUTION",
                description="Implementing the planned changes or actions",
                keywords=[
                    "change",
                    "modify",
                    "create",
                    "add",
                    "remove",
                    "fix",
                    "implement",
                    "write",
                    "update",
                    "refactor",
                    "build",
                    "configure",
                    "set up",
                    "install",
                    "run",
                    "execute",
                ],
                next_stages={"VERIFICATION", "COMPLETION"},
            ),
            "VERIFICATION": StageDefinition(
                name="VERIFICATION",
                description="Validating results and testing outcomes",
                keywords=[
                    "test",
                    "verify",
                    "check",
                    "validate",
                    "confirm",
                    "ensure",
                    "run tests",
                    "build",
                    "compile",
                    "lint",
                ],
                next_stages={"COMPLETION", "EXECUTION"},
            ),
            "COMPLETION": StageDefinition(
                name="COMPLETION",
                description="Finalizing, documenting, and wrapping up",
                keywords=[
                    "done",
                    "finish",
                    "complete",
                    "commit",
                    "summarize",
                    "document",
                    "conclude",
                    "wrap up",
                    "finalize",
                ],
                next_stages=set(),
            ),
        }

    @classmethod
    def get_provider_hints(cls) -> Dict[str, Any]:
        """Get hints for provider selection.

        Returns:
            Dictionary with provider preferences.

        Default implementation uses VerticalConfigRegistry. Override in subclasses
        for vertical-specific requirements.
        """
        from victor.core.verticals.config_registry import VerticalConfigRegistry

        # Try to get from registry based on vertical name
        try:
            return VerticalConfigRegistry.get_provider_hints(cls.name)
        except KeyError:
            # Fallback to generic defaults
            return {
                "preferred_providers": ["anthropic", "openai"],
                "min_context_window": 100000,
                "requires_tool_calling": True,
            }

    @classmethod
    def get_evaluation_criteria(cls) -> List[str]:
        """Get criteria for evaluating agent performance.

        Returns:
            List of evaluation criteria descriptions.

        Default implementation uses VerticalConfigRegistry. Override in subclasses
        for vertical-specific requirements.
        """
        from victor.core.verticals.config_registry import VerticalConfigRegistry

        # Try to get from registry based on vertical name
        try:
            return VerticalConfigRegistry.get_evaluation_criteria(cls.name)
        except KeyError:
            # Fallback to generic defaults
            return [
                "Task completion accuracy",
                "Tool usage efficiency",
                "Response relevance",
            ]

    @classmethod
    def get_tiered_tool_config(cls) -> Optional["TieredToolConfig"]:
        """Get tiered tool configuration for this vertical.

        TieredToolConfig defines mandatory, vertical_core, and semantic_pool
        tool sets for intelligent tool filtering by ToolAccessController.

        Default implementation uses TieredToolTemplate to generate config
        based on vertical name. Override for custom configurations.

        Returns:
            TieredToolConfig or None if vertical doesn't use tiered config.
        """
        from victor.core.vertical_types import TieredToolTemplate

        # Try to get pre-built config from template
        return TieredToolTemplate.for_vertical(cls.name)

    @classmethod
    def customize_config(cls, config: VerticalConfig) -> VerticalConfig:
        """Hook for final configuration customization.

        Override to modify the config before it's returned.

        Args:
            config: Configuration to customize.

        Returns:
            Customized configuration.
        """
        return config

    # =========================================================================
    # Extension Protocol Methods (Optional)
    # =========================================================================
    # These methods enable verticals to provide framework extensions.
    # Override them to integrate with the framework's middleware, safety,
    # prompt, and configuration systems.

    @classmethod
    def get_middleware(cls) -> List[Any]:
        """Get middleware implementations for this vertical.

        Override to provide vertical-specific middleware for tool
        execution processing.

        Returns:
            List of middleware implementations (MiddlewareProtocol)
        """
        return []

    @classmethod
    def get_safety_extension(cls) -> Optional[Any]:
        """Get safety extension for this vertical.

        Override to provide vertical-specific dangerous operation patterns.

        Returns:
            Safety extension (SafetyExtensionProtocol) or None
        """
        return None

    @classmethod
    def get_prompt_contributor(cls) -> Optional[Any]:
        """Get prompt contributor for this vertical.

        Override to provide vertical-specific task hints and prompt sections.

        Returns:
            Prompt contributor (PromptContributorProtocol) or None
        """
        return None

    @classmethod
    def get_mode_config_provider(cls) -> Optional[Any]:
        """Get mode configuration provider for this vertical.

        Override to provide vertical-specific operational modes.

        Returns:
            Mode config provider (ModeConfigProviderProtocol) or None
        """
        return None

    @classmethod
    def get_mode_config(cls) -> Dict[str, Any]:
        """Get mode configurations for this vertical.

        Returns operational modes like 'fast', 'thorough', 'explore' with
        their configurations (tool_budget, max_iterations, temperature).

        Default implementation provides standard modes. Override in subclasses
        for vertical-specific mode configurations.

        Returns:
            Dictionary mapping mode names to ModeConfig-like dicts.
        """
        return {
            "fast": {
                "name": "fast",
                "tool_budget": 10,
                "max_iterations": 20,
                "temperature": 0.7,
                "description": "Quick responses with limited tool usage",
            },
            "thorough": {
                "name": "thorough",
                "tool_budget": 50,
                "max_iterations": 50,
                "temperature": 0.7,
                "description": "Comprehensive analysis with extensive tool usage",
            },
            "explore": {
                "name": "explore",
                "tool_budget": 30,
                "max_iterations": 30,
                "temperature": 0.9,
                "description": "Exploratory mode with higher creativity",
            },
        }

    @classmethod
    def get_task_type_hints(cls) -> Dict[str, Any]:
        """Get task-type-specific prompt hints.

        Returns hints for common task types (edit, search, explain, etc.)
        with tool priorities and budget recommendations.

        Default implementation provides standard hints. Override in subclasses
        for vertical-specific task type hints.

        Returns:
            Dictionary mapping task types to TaskTypeHint-like dicts.
        """
        return {
            "edit": {
                "task_type": "edit",
                "hint": "[EDIT MODE] Read target files first, then make focused modifications.",
                "tool_budget": 15,
                "priority_tools": ["read", "edit", "grep"],
            },
            "search": {
                "task_type": "search",
                "hint": "[SEARCH MODE] Use semantic search and grep for efficient discovery.",
                "tool_budget": 10,
                "priority_tools": ["grep", "code_search", "ls"],
            },
            "explain": {
                "task_type": "explain",
                "hint": "[EXPLAIN MODE] Read relevant code and provide clear explanations.",
                "tool_budget": 8,
                "priority_tools": ["read", "grep", "overview"],
            },
            "debug": {
                "task_type": "debug",
                "hint": "[DEBUG MODE] Investigate systematically, check logs and error messages.",
                "tool_budget": 20,
                "priority_tools": ["read", "grep", "shell", "run_tests"],
            },
            "implement": {
                "task_type": "implement",
                "hint": "[IMPLEMENT MODE] Plan first, implement incrementally, verify each step.",
                "tool_budget": 30,
                "priority_tools": ["read", "write", "edit", "shell"],
            },
        }

    @classmethod
    def get_tool_dependency_provider(cls) -> Optional[Any]:
        """Get tool dependency provider for this vertical.

        Override to provide vertical-specific tool execution patterns.

        Returns:
            Tool dependency provider (ToolDependencyProviderProtocol) or None
        """
        return None

    @classmethod
    def get_tool_graph(cls) -> Optional[Any]:
        """Get tool execution graph for this vertical.

        Override to provide a custom ToolExecutionGraph that defines
        tool dependencies, transitions, and execution sequences.
        The graph is registered with the global ToolGraphRegistry.

        Returns:
            ToolExecutionGraph instance or None (no graph registered)
        """
        return None

    @classmethod
    def get_handlers(cls) -> Dict[str, Any]:
        """Get compute handlers for workflow execution.

        Override to provide domain-specific handlers for workflow nodes.
        These handlers are registered with the HandlerRegistry during
        vertical integration, replacing the previous import-side-effect
        registration pattern.

        Example:
            @classmethod
            def get_handlers(cls) -> Dict[str, Any]:
                from victor.coding.handlers import HANDLERS
                return HANDLERS

        Returns:
            Dict mapping handler name to handler instance
        """
        return {}

    @classmethod
    def get_tiered_tools(cls) -> Optional[Any]:
        """Get tiered tool configuration for intelligent selection.

        DEPRECATED: Use get_tiered_tool_config() instead.

        This method is maintained for backward compatibility. New verticals
        should override get_tiered_tool_config() which has a default
        implementation using TieredToolTemplate.

        ISP/LSP Compliance: This method now delegates to get_tiered_tool_config()
        to ensure consistent behavior regardless of which method is called.

        Override to provide vertical-specific tiered tool configuration
        for context-efficient tool selection. When implemented, this enables:

        1. Mandatory tools: Always included (e.g., read, ls)
        2. Vertical core: Always included for this vertical (e.g., web, fetch for research)
        3. Semantic pool: Selected based on query similarity and stage

        Example for research vertical:
            return TieredToolConfig(
                mandatory={"read", "ls"},
                vertical_core={"web", "fetch"},
                semantic_pool={"write", "edit", "grep", "search"},
                stage_tools={
                    "WRITING": {"write", "edit"},
                    "SEARCHING": {"web", "fetch", "grep"},
                },
                readonly_only_for_analysis=True,
            )

        Returns:
            TieredToolConfig or None (falls back to get_tools())
        """
        # ISP/LSP: Delegate to canonical method for consistent behavior
        return cls.get_tiered_tool_config()

    @classmethod
    def get_workflow_provider(cls) -> Optional[Any]:
        """Get workflow provider for this vertical.

        Override to provide vertical-specific workflows.

        Returns:
            Workflow provider (WorkflowProviderProtocol) or None
        """
        return None

    @classmethod
    def get_rl_config_provider(cls) -> Optional[Any]:
        """Get RL configuration provider for this vertical.

        Override to provide vertical-specific RL learner configurations,
        task type mappings, and quality thresholds.

        Returns:
            RL config provider (RLConfigProviderProtocol) or None
        """
        return None

    @classmethod
    def get_rl_hooks(cls) -> Optional[Any]:
        """Get RL hooks for outcome recording.

        Override to provide vertical-specific RL hooks for
        recording task outcomes and updating learners.

        Returns:
            RLHooks instance or None
        """
        return None

    @classmethod
    def get_team_spec_provider(cls) -> Optional[Any]:
        """Get team specification provider for this vertical.

        Override to provide vertical-specific multi-agent team
        configurations for complex task execution.

        Returns:
            Team spec provider (TeamSpecProviderProtocol) or None
        """
        return None

    @classmethod
    def get_service_provider(cls) -> Optional[Any]:
        """Get service provider for this vertical.

        By default, returns a BaseVerticalServiceProvider that registers
        the vertical's prompt contributor, safety extension, mode config,
        and tool dependency providers with the DI container.

        Override to provide custom service registration logic.

        Returns:
            Service provider (ServiceProviderProtocol) or factory-created provider
        """
        try:
            from victor.core.verticals.base_service_provider import VerticalServiceProviderFactory

            return VerticalServiceProviderFactory.create(cls)
        except ImportError:
            return None

    @classmethod
    def get_enrichment_strategy(cls) -> Optional[Any]:
        """Get vertical-specific enrichment strategy.

        Override to provide vertical-specific prompt enrichment strategies
        for DSPy-like auto prompt optimization. Enrichments can include:
        - Knowledge graph symbols and related code snippets (coding)
        - Web search results and source citations (research)
        - Infrastructure context and command patterns (devops)
        - Schema context and query patterns (data analysis)

        Returns:
            EnrichmentStrategyProtocol implementation or None
        """
        return None

    @classmethod
    def get_extensions(
        cls,
        *,
        use_cache: bool = True,
        strict: Optional[bool] = None,
    ) -> "VerticalExtensions":
        """Get all extensions for this vertical with strict error handling.

        Aggregates all extension implementations for framework integration.
        Override for custom extension aggregation.

        LSP Compliance: This method ALWAYS returns a valid VerticalExtensions
        object, never None. Even on exceptions (in non-strict mode), it returns
        a VerticalExtensions with successfully loaded extensions.

        Error Handling Modes:
        - strict=True: Raises ExtensionLoadError on ANY extension failure
        - strict=False: Collects errors, logs warnings, returns partial extensions
        - strict=None: Uses class-level strict_extension_loading setting

        Required Extensions:
        Even when strict=False, extensions listed in required_extensions will
        raise ExtensionLoadError if they fail to load.

        Args:
            use_cache: If True (default), return cached extensions if available.
                       Set to False to force rebuild.
            strict: Override the class-level strict_extension_loading setting.
                    If None (default), uses cls.strict_extension_loading.

        Returns:
            VerticalExtensions containing all vertical extensions (never None)

        Raises:
            ExtensionLoadError: In strict mode or when a required extension fails
        """
        from victor.core.errors import ExtensionLoadError
        from victor.core.verticals.protocols import VerticalExtensions

        cache_key = cls.__name__

        # Return cached extensions if available and caching enabled
        if use_cache and cache_key in cls._extensions_cache:
            return cls._extensions_cache[cache_key]

        # Determine strict mode
        is_strict = strict if strict is not None else cls.strict_extension_loading

        # Collect errors for reporting
        errors: List["ExtensionLoadError"] = []

        def _load_extension(
            extension_type: str,
            loader: callable,
            is_list: bool = False,
        ) -> Any:
            """Load an extension with error handling.

            Args:
                extension_type: Type name for error reporting
                loader: Callable that loads the extension
                is_list: If True, the extension should be a list

            Returns:
                The loaded extension, or default value on error
            """
            try:
                result = loader()
                return result
            except Exception as e:
                is_required = extension_type in cls.required_extensions
                error = ExtensionLoadError(
                    message=f"Failed to load '{extension_type}' extension for vertical '{cls.name}': {e}",
                    extension_type=extension_type,
                    vertical_name=cls.name,
                    original_error=e,
                    is_required=is_required,
                )
                errors.append(error)

                # Log the error with appropriate severity
                if is_strict or is_required:
                    logger.error(
                        f"[{error.correlation_id}] {extension_type} extension failed to load "
                        f"for vertical '{cls.name}': {e}",
                        exc_info=True,
                    )
                else:
                    logger.warning(
                        f"[{error.correlation_id}] {extension_type} extension failed to load "
                        f"for vertical '{cls.name}': {e}"
                    )

                # Return default value
                return [] if is_list else None

        # Load each extension with error handling
        middleware = _load_extension("middleware", cls.get_middleware, is_list=True)
        safety = _load_extension("safety", cls.get_safety_extension)
        prompt = _load_extension("prompt", cls.get_prompt_contributor)
        mode_config = _load_extension("mode_config", cls.get_mode_config_provider)
        tool_deps = _load_extension("tool_deps", cls.get_tool_dependency_provider)
        workflow = _load_extension("workflow", cls.get_workflow_provider)
        service = _load_extension("service", cls.get_service_provider)
        rl_config = _load_extension("rl_config", cls.get_rl_config_provider)
        team_spec = _load_extension("team_spec", cls.get_team_spec_provider)
        enrichment = _load_extension("enrichment", cls.get_enrichment_strategy)
        tiered_tools = _load_extension("tiered_tools", cls.get_tiered_tool_config)

        # Check for critical failures (strict mode or required extensions)
        critical_errors = [e for e in errors if is_strict or e.is_required]
        if critical_errors:
            # Raise the first critical error
            raise critical_errors[0]

        # Log summary if there were non-critical errors
        if errors:
            logger.warning(
                f"Vertical '{cls.name}' loaded with {len(errors)} extension error(s). "
                f"Affected extensions: {', '.join(e.extension_type for e in errors)}"
            )

        # Build extensions object
        extensions = VerticalExtensions(
            middleware=middleware if middleware else [],
            safety_extensions=[safety] if safety else [],
            prompt_contributors=[prompt] if prompt else [],
            mode_config_provider=mode_config,
            tool_dependency_provider=tool_deps,
            workflow_provider=workflow,
            service_provider=service,
            rl_config_provider=rl_config,
            team_spec_provider=team_spec,
            enrichment_strategy=enrichment,
            tiered_tool_config=tiered_tools,
        )

        # Cache the extensions
        cls._extensions_cache[cache_key] = extensions
        return extensions

    # =========================================================================
    # Template Method Implementation
    # =========================================================================

    @classmethod
    def get_config(cls, *, use_cache: bool = True) -> VerticalConfig:
        """Get the complete configuration for this vertical.

        This is the main template method that assembles the configuration
        by calling the various override points.

        Args:
            use_cache: If True (default), return cached config if available.
                       Set to False to force rebuild.

        Returns:
            Complete VerticalConfig for agent creation.
        """
        cache_key = cls.__name__

        # Return cached config if available and caching enabled
        if use_cache and cache_key in cls._config_cache:
            return cls._config_cache[cache_key]

        # Build tool set
        tool_names = cls.get_tools()
        tools = ToolSet.from_tools(tool_names)

        # Build config
        config = VerticalConfig(
            tools=tools,
            system_prompt=cls.get_system_prompt(),
            stages=cls.get_stages(),
            provider_hints=cls.get_provider_hints(),
            evaluation_criteria=cls.get_evaluation_criteria(),
            metadata={
                "vertical_name": cls.name,
                "vertical_version": cls.version,
                "description": cls.description,
            },
        )

        # Allow final customization
        config = cls.customize_config(config)

        # Cache the config
        cls._config_cache[cache_key] = config
        return config

    @classmethod
    def clear_config_cache(cls, *, clear_all: bool = False) -> None:
        """Clear the config cache for this vertical.

        Also clears individual extension cache entries created by
        _get_cached_extension() for this class.

        Args:
            clear_all: If True, clear cache for all verticals.
                       If False (default), clear only for this class.
        """
        if clear_all:
            cls._config_cache.clear()
            cls._extensions_cache.clear()
        else:
            cache_key = cls.__name__
            cls._config_cache.pop(cache_key, None)
            # Clear composite extensions cache entry
            cls._extensions_cache.pop(cache_key, None)
            # Also clear individual extension cache entries (format: "ClassName:key")
            prefix = f"{cache_key}:"
            keys_to_remove = [k for k in cls._extensions_cache if k.startswith(prefix)]
            for key in keys_to_remove:
                cls._extensions_cache.pop(key, None)

    @classmethod
    def get_tool_set(cls) -> ToolSet:
        """Get the ToolSet for this vertical.

        Convenience method that returns just the tool configuration.

        Returns:
            Configured ToolSet.
        """
        return ToolSet.from_tools(cls.get_tools())

    @classmethod
    async def create_agent(
        cls,
        provider: str = "anthropic",
        model: Optional[str] = None,
        **kwargs: Any,
    ) -> Any:
        """Factory method to create an agent with this vertical's config.

        Args:
            provider: LLM provider name.
            model: Optional model identifier.
            **kwargs: Additional arguments passed to Agent.create().

        Returns:
            Configured Agent instance.
        """
        from victor.framework import Agent

        config = cls.get_config()
        agent_kwargs = config.to_agent_kwargs()
        agent_kwargs.update(kwargs)

        return await Agent.create(
            provider=provider,
            model=model,
            **agent_kwargs,
        )


class VerticalRegistry:
    """Registry for discovering and accessing verticals.

    Implements the Registry pattern for vertical discovery.

    Supports both built-in verticals and external verticals installed as
    pip packages via entry_points. External packages can register verticals
    using the 'victor.verticals' entry point group.

    Example:
        # Register a vertical
        VerticalRegistry.register(MyVertical)

        # List available verticals
        for name, vertical in VerticalRegistry.list_all():
            print(f"{name}: {vertical.description}")

        # Get a specific vertical
        coding = VerticalRegistry.get("coding")

    Entry Point Format (for external packages):
        # In external package's pyproject.toml
        [project.entry-points."victor.verticals"]
        security = "victor_security:SecurityAssistant"
    """

    _registry: Dict[str, Type[VerticalBase]] = {}
    _external_discovered: bool = False
    ENTRY_POINT_GROUP: str = "victor.verticals"

    @classmethod
    def register(cls, vertical: Type[VerticalBase]) -> None:
        """Register a vertical.

        Args:
            vertical: Vertical class to register.

        Raises:
            ValueError: If vertical has no name.
        """
        if not vertical.name:
            raise ValueError(f"Vertical {vertical.__name__} has no name defined")
        cls._registry[vertical.name] = vertical

    @classmethod
    def unregister(cls, name: str) -> None:
        """Unregister a vertical.

        Args:
            name: Vertical name to unregister.
        """
        if name in cls._registry:
            del cls._registry[name]

    @classmethod
    def get(cls, name: str) -> Optional[Type[VerticalBase]]:
        """Get a vertical by name.

        Args:
            name: Vertical name.

        Returns:
            Vertical class or None if not found.
        """
        return cls._registry.get(name)

    @classmethod
    def list_all(cls) -> List[tuple[str, Type[VerticalBase]]]:
        """List all registered verticals.

        Returns:
            List of (name, vertical_class) tuples.
        """
        return list(cls._registry.items())

    @classmethod
    def list_names(cls) -> List[str]:
        """List all registered vertical names.

        Returns:
            List of vertical names.
        """
        return list(cls._registry.keys())

    @classmethod
    def clear(cls, *, reregister_builtins: bool = True) -> None:
        """Clear all registered verticals (for testing).

        Args:
            reregister_builtins: If True (default), re-register built-in verticals
                after clearing. This prevents test pollution where clearing in one
                test affects other tests that expect built-ins to be available.
        """
        cls._registry.clear()
        cls._external_discovered = False

        if reregister_builtins:
            # Re-register built-in verticals to prevent test pollution
            from victor.core.verticals import _register_builtin_verticals

            _register_builtin_verticals()

    @classmethod
    def discover_external_verticals(cls) -> Dict[str, Type[VerticalBase]]:
        """Discover and register external verticals from entry points.

        Scans installed packages for the 'victor.verticals' entry point group
        and registers any valid vertical classes found. External verticals must:
        - Inherit from VerticalBase
        - Have a non-empty 'name' attribute

        Returns:
            Dictionary of newly discovered vertical names to their classes.

        Example entry point in external package's pyproject.toml:
            [project.entry-points."victor.verticals"]
            security = "victor_security:SecurityAssistant"

        This would load SecurityAssistant from the victor_security package
        and register it if it's a valid VerticalBase subclass.
        """
        import logging
        from importlib.metadata import entry_points

        logger = logging.getLogger(__name__)
        discovered: Dict[str, Type[VerticalBase]] = {}

        # Avoid re-discovery on repeated calls
        if cls._external_discovered:
            return discovered

        try:
            # Python 3.10+ API: entry_points() returns a SelectableGroups object
            # Use group parameter for filtering
            eps = entry_points(group=cls.ENTRY_POINT_GROUP)
        except TypeError:
            # Fallback for older Python versions (shouldn't happen with Python 3.10+)
            all_eps = entry_points()
            eps = all_eps.get(cls.ENTRY_POINT_GROUP, [])

        for ep in eps:
            try:
                # Load the entry point (imports the module and gets the object)
                vertical_class = ep.load()

                # Validate that it's a proper VerticalBase subclass
                if not cls._validate_external_vertical(vertical_class, ep.name):
                    continue

                # Check for name conflicts with existing verticals
                if vertical_class.name in cls._registry:
                    existing = cls._registry[vertical_class.name]
                    logger.warning(
                        f"External vertical '{ep.name}' has name '{vertical_class.name}' "
                        f"which conflicts with existing vertical {existing.__name__}. "
                        f"Skipping registration."
                    )
                    continue

                # Register the vertical
                cls.register(vertical_class)
                discovered[vertical_class.name] = vertical_class
                logger.info(
                    f"Discovered external vertical: {vertical_class.name} " f"(from {ep.value})"
                )

            except Exception as e:
                # Log the error but continue with other entry points
                logger.warning(
                    f"Failed to load external vertical '{ep.name}' from "
                    f"entry point '{ep.value}': {e}"
                )
                continue

        cls._external_discovered = True

        if discovered:
            logger.info(
                f"Discovered {len(discovered)} external vertical(s): "
                f"{', '.join(discovered.keys())}"
            )

        return discovered

    @classmethod
    def _validate_external_vertical(
        cls,
        vertical_class: Any,
        entry_point_name: str,
    ) -> bool:
        """Validate that an external vertical class is properly implemented.

        Args:
            vertical_class: The class loaded from the entry point.
            entry_point_name: Name of the entry point (for error messages).

        Returns:
            True if the vertical is valid, False otherwise.
        """
        import logging

        logger = logging.getLogger(__name__)

        # Check if it's a class
        if not isinstance(vertical_class, type):
            logger.warning(
                f"External vertical '{entry_point_name}' is not a class "
                f"(got {type(vertical_class).__name__}). Skipping."
            )
            return False

        # Check if it inherits from VerticalBase
        if not issubclass(vertical_class, VerticalBase):
            logger.warning(
                f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                f"does not inherit from VerticalBase. Skipping."
            )
            return False

        # Check if it has a name defined
        if not getattr(vertical_class, "name", None):
            logger.warning(
                f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                f"has no 'name' attribute defined. Skipping."
            )
            return False

        # Check if abstract methods are implemented
        # VerticalBase requires get_tools() and get_system_prompt()
        try:
            # Try to call the abstract methods to ensure they're implemented
            # These are classmethods so we can call them on the class
            tools = vertical_class.get_tools()
            if not isinstance(tools, list):
                logger.warning(
                    f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                    f"get_tools() must return a list. Skipping."
                )
                return False

            prompt = vertical_class.get_system_prompt()
            if not isinstance(prompt, str):
                logger.warning(
                    f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                    f"get_system_prompt() must return a string. Skipping."
                )
                return False
        except NotImplementedError:
            logger.warning(
                f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                f"has unimplemented abstract methods. Skipping."
            )
            return False
        except Exception as e:
            logger.warning(
                f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                f"failed validation: {e}. Skipping."
            )
            return False

        return True

    @classmethod
    def reset_discovery(cls) -> None:
        """Reset the external discovery flag (for testing).

        This allows discover_external_verticals() to run again.
        """
        cls._external_discovered = False
