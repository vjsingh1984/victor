# Copyright 2025 Vijaykumar Singh <singhvjd@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""VerticalBase - Abstract base class for domain-specific assistants.

Implements the Template Method pattern where:
- VerticalBase defines the skeleton of creating an agent
- Concrete verticals override specific configuration steps

Design Patterns:
    - Template Method: Define skeleton, override steps
    - Factory Method: create_agent() factory
    - Registry: VerticalRegistry for discovery

Architecture (Phase 2.3 - SRP Compliance):
    VerticalBase now composes functionality from focused classes:
    - VerticalMetadataProvider: Metadata (name, description, provider hints, etc.)
    - VerticalExtensionLoader: Extension loading and caching
    - VerticalWorkflowProvider: Workflow and handler providers

Example:
    class MyCustomVertical(VerticalBase):
        name = "my_vertical"
        description = "Custom assistant for X"

        @classmethod
        def get_tools(cls) -> List[str]:
            return ["read", "write", "custom_tool"]

        @classmethod
        def get_system_prompt(cls) -> str:
            return "You are an expert in X..."
"""

from __future__ import annotations

import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Any, ClassVar, Dict, List, Optional, Set, Type, TYPE_CHECKING

from victor.framework.tools import ToolSet

# Import focused capability providers for SRP compliance
from victor.core.verticals.metadata import VerticalMetadataProvider
from victor.core.verticals.extension_loader import VerticalExtensionLoader
from victor.core.verticals.workflow_provider import VerticalWorkflowProvider

if TYPE_CHECKING:
    from victor.core.verticals.protocols import VerticalExtensions

# Import StageDefinition from core for centralized definition
# Re-export for backward compatibility
from victor.core.vertical_types import StageDefinition

logger = logging.getLogger(__name__)


@dataclass
class VerticalConfig:
    """Configuration generated by a vertical.

    This is passed to Agent.create() to configure the agent.

    Attributes:
        tools: ToolSet configuration
        system_prompt: System prompt text
        stages: Stage definitions
        provider_hints: Hints for provider selection
        evaluation_criteria: Criteria for evaluating agent performance
        metadata: Additional vertical-specific metadata
    """

    tools: ToolSet
    system_prompt: str
    stages: Dict[str, StageDefinition] = field(default_factory=dict)
    provider_hints: Dict[str, Any] = field(default_factory=dict)
    evaluation_criteria: List[str] = field(default_factory=list)
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_agent_kwargs(self) -> Dict[str, Any]:
        """Convert to kwargs for Agent.create().

        Returns:
            Dictionary of keyword arguments.
        """
        return {
            "tools": self.tools,
            # System prompt is typically handled separately
        }

    def to_dict(self) -> Dict[str, Any]:
        """Convert config to dictionary for dict-like access.

        Returns:
            Dictionary representation of the configuration.
        """
        return {
            "tools": self.tools.tools if self.tools else [],
            "system_prompt": self.system_prompt,
            "stages": {
                k: {"name": v.name, "description": v.description} for k, v in self.stages.items()
            },
            "provider_hints": self.provider_hints,
            "evaluation_criteria": self.evaluation_criteria,
            "metadata": self.metadata,
        }

    def keys(self):
        """Return keys for dict-like access compatibility.

        Returns:
            Keys iterator for dictionary representation.
        """
        return self.to_dict().keys()

    def __getitem__(self, key: str) -> Any:
        """Enable dict-like access: config["key"].

        Args:
            key: Configuration key

        Returns:
            Configuration value

        Raises:
            KeyError: If key not found
        """
        d = self.to_dict()
        if key not in d:
            raise KeyError(key)
        return d[key]

    def get(self, key: str, default: Any = None) -> Any:
        """Get config value with default, like dict.get().

        Args:
            key: Configuration key
            default: Default value if key not found

        Returns:
            Configuration value or default
        """
        try:
            return self[key]
        except KeyError:
            return default


class VerticalBase(
    VerticalMetadataProvider,
    VerticalExtensionLoader,
    VerticalWorkflowProvider,
    ABC,
):
    """Abstract base class for domain-specific assistants.

    Implements the Template Method pattern using composition of focused
    capability providers for SRP compliance:

    - VerticalMetadataProvider: Metadata (name, description, version,
      provider_hints, evaluation_criteria, capability_configs)
    - VerticalExtensionLoader: Extension loading (middleware, safety,
      prompt_contributor, mode_config, tool_deps, etc.)
    - VerticalWorkflowProvider: Workflow and handler providers

    Subclasses must override:
    - name: Vertical identifier
    - description: Human-readable description
    - get_tools(): List of tool names
    - get_system_prompt(): System prompt text

    Optional overrides:
    - get_stages(): Stage definitions
    - customize_config(): Hook for final config customization
    - Extension methods: get_middleware(), get_safety_extension(), etc.

    Example:
        class SecurityAuditor(VerticalBase):
            name = "security_auditor"
            description = "Security vulnerability analysis"

            @classmethod
            def get_tools(cls):
                return ["read", "search", "security_scan"]

            @classmethod
            def get_system_prompt(cls):
                return "You are a security expert..."

    Config Caching:
        The get_config() method caches its result per-class to avoid
        repeated computation. Call clear_config_cache() to invalidate
        when config sources change (typically only needed in tests).

    Extension Loading:
        The get_extensions() method supports strict error handling.
        Set strict_extension_loading=True to raise ExtensionLoadError on
        any failure. Set required_extensions to specify which extensions
        must load successfully even in non-strict mode.

    Backward Compatibility:
        All methods from the original VerticalBase are preserved through
        inheritance from the focused provider classes. Existing verticals
        that inherit from VerticalBase require no changes.
    """

    # Config cache (keyed by class name, stores VerticalConfig)
    _config_cache: Dict[str, "VerticalConfig"] = {}

    # =========================================================================
    # Required Abstract Methods
    # =========================================================================

    @classmethod
    @abstractmethod
    def get_tools(cls) -> List[str]:
        """Get the list of tool names for this vertical.

        Returns:
            List of tool names to enable.
        """
        pass

    @classmethod
    @abstractmethod
    def get_system_prompt(cls) -> str:
        """Get the system prompt for this vertical.

        Returns:
            System prompt text with domain expertise.
        """
        pass

    # =========================================================================
    # Configurable Override Points
    # =========================================================================

    @classmethod
    def get_stages(cls) -> Dict[str, StageDefinition]:
        """Get stage definitions for this vertical.

        Default implementation provides a comprehensive 7-stage workflow
        representing a generic problem-solving lifecycle:

        1. INITIAL: Understand the request and gather initial context
        2. PLANNING: Design the approach and strategy
        3. READING: Gather detailed information and context
        4. ANALYSIS: Analyze information and identify solutions
        5. EXECUTION: Implement the planned changes
        6. VERIFICATION: Validate results and test outcomes
        7. COMPLETION: Finalize, document, and wrap up

        This workflow applies to most domains:
        - Coding: understand -> plan -> read code -> analyze -> implement -> test -> commit
        - DevOps: assess -> plan -> implement -> validate -> deploy -> monitor
        - Research: question -> search -> read -> synthesize -> write -> verify
        - Data Analysis: understand -> explore -> analyze -> visualize -> report

        Verticals should override this method to provide domain-specific:
        - Stage names (e.g., DEPLOYMENT, SYNTHESIZING)
        - Tools appropriate for each stage
        - Domain-specific keywords

        Returns:
            Dictionary mapping stage names to StageDefinition objects.
            Each stage includes description, keywords, and valid transitions.
        """
        return {
            "INITIAL": StageDefinition(
                name="INITIAL",
                description="Understanding the request and gathering initial context",
                keywords=[
                    "what",
                    "how",
                    "explain",
                    "help",
                    "where",
                    "show me",
                    "describe",
                    "overview",
                    "understand",
                    "clarify",
                ],
                next_stages={"PLANNING", "READING"},
            ),
            "PLANNING": StageDefinition(
                name="PLANNING",
                description="Designing the approach and creating a strategy",
                keywords=[
                    "plan",
                    "approach",
                    "strategy",
                    "design",
                    "architecture",
                    "outline",
                    "steps",
                    "roadmap",
                    "how should",
                    "what's the best way",
                ],
                next_stages={"READING", "EXECUTION"},
            ),
            "READING": StageDefinition(
                name="READING",
                description="Gathering detailed information and context",
                keywords=[
                    "read",
                    "show",
                    "find",
                    "search",
                    "look",
                    "check",
                    "examine",
                    "inspect",
                    "review",
                    "fetch",
                    "get",
                    "retrieve",
                ],
                next_stages={"ANALYSIS", "EXECUTION"},
            ),
            "ANALYSIS": StageDefinition(
                name="ANALYSIS",
                description="Analyzing information and identifying solutions",
                keywords=[
                    "analyze",
                    "review",
                    "understand",
                    "why",
                    "how does",
                    "compare",
                    "evaluate",
                    "assess",
                    "investigate",
                    "diagnose",
                ],
                next_stages={"EXECUTION", "PLANNING"},
            ),
            "EXECUTION": StageDefinition(
                name="EXECUTION",
                description="Implementing the planned changes or actions",
                keywords=[
                    "change",
                    "modify",
                    "create",
                    "add",
                    "remove",
                    "fix",
                    "implement",
                    "write",
                    "update",
                    "refactor",
                    "build",
                    "configure",
                    "set up",
                    "install",
                    "run",
                    "execute",
                ],
                next_stages={"VERIFICATION", "COMPLETION"},
            ),
            "VERIFICATION": StageDefinition(
                name="VERIFICATION",
                description="Validating results and testing outcomes",
                keywords=[
                    "test",
                    "verify",
                    "check",
                    "validate",
                    "confirm",
                    "ensure",
                    "run tests",
                    "build",
                    "compile",
                    "lint",
                ],
                next_stages={"COMPLETION", "EXECUTION"},
            ),
            "COMPLETION": StageDefinition(
                name="COMPLETION",
                description="Finalizing, documenting, and wrapping up",
                keywords=[
                    "done",
                    "finish",
                    "complete",
                    "commit",
                    "summarize",
                    "document",
                    "conclude",
                    "wrap up",
                    "finalize",
                ],
                next_stages=set(),
            ),
        }

    @classmethod
    def customize_config(cls, config: VerticalConfig) -> VerticalConfig:
        """Hook for final configuration customization.

        Override to modify the config before it's returned.

        Args:
            config: Configuration to customize.

        Returns:
            Customized configuration.
        """
        return config

    # =========================================================================
    # Template Method Implementation
    # =========================================================================

    @classmethod
    def get_config(cls, *, use_cache: bool = True) -> VerticalConfig:
        """Get the complete configuration for this vertical.

        This is the main template method that assembles the configuration
        by calling the various override points.

        Args:
            use_cache: If True (default), return cached config if available.
                       Set to False to force rebuild.

        Returns:
            Complete VerticalConfig for agent creation.
        """
        cache_key = cls.__name__

        # Return cached config if available and caching enabled
        if use_cache and cache_key in cls._config_cache:
            return cls._config_cache[cache_key]

        # Build tool set
        tool_names = cls.get_tools()
        tools = ToolSet.from_tools(tool_names)

        # Build config
        config = VerticalConfig(
            tools=tools,
            system_prompt=cls.get_system_prompt(),
            stages=cls.get_stages(),
            provider_hints=cls.get_provider_hints(),
            evaluation_criteria=cls.get_evaluation_criteria(),
            metadata={
                "vertical_name": cls.name,
                "vertical_version": cls.version,
                "description": cls.description,
            },
        )

        # Allow final customization
        config = cls.customize_config(config)

        # Cache the config
        cls._config_cache[cache_key] = config
        return config

    @classmethod
    def clear_config_cache(cls, *, clear_all: bool = False) -> None:
        """Clear the config cache for this vertical.

        Also clears individual extension cache entries created by
        _get_cached_extension() for this class.

        Args:
            clear_all: If True, clear cache for all verticals.
                       If False (default), clear only for this class.
        """
        if clear_all:
            cls._config_cache.clear()
            cls.clear_extension_cache(clear_all=True)
        else:
            cache_key = cls.__name__
            cls._config_cache.pop(cache_key, None)
            # Clear extensions cache for this class too
            cls.clear_extension_cache(clear_all=False)

    @classmethod
    def get_tool_set(cls) -> ToolSet:
        """Get the ToolSet for this vertical.

        Convenience method that returns just the tool configuration.

        Returns:
            Configured ToolSet.
        """
        return ToolSet.from_tools(cls.get_tools())

    @classmethod
    async def create_agent(
        cls,
        provider: str = "anthropic",
        model: Optional[str] = None,
        **kwargs: Any,
    ) -> Any:
        """Factory method to create an agent with this vertical's config.

        Args:
            provider: LLM provider name.
            model: Optional model identifier.
            **kwargs: Additional arguments passed to Agent.create().

        Returns:
            Configured Agent instance.
        """
        from victor.framework import Agent

        config = cls.get_config()
        agent_kwargs = config.to_agent_kwargs()
        agent_kwargs.update(kwargs)

        return await Agent.create(
            provider=provider,
            model=model,
            **agent_kwargs,
        )


class VerticalRegistry:
    """Registry for discovering and accessing verticals.

    Implements the Registry pattern for vertical discovery.

    Supports both built-in verticals and external verticals installed as
    pip packages via entry_points. External packages can register verticals
    using the 'victor.verticals' entry point group.

    Example:
        # Register a vertical
        VerticalRegistry.register(MyVertical)

        # List available verticals
        for name, vertical in VerticalRegistry.list_all():
            print(f"{name}: {vertical.description}")

        # Get a specific vertical
        coding = VerticalRegistry.get("coding")

    Entry Point Format (for external packages):
        # In external package's pyproject.toml
        [project.entry-points."victor.verticals"]
        security = "victor_security:SecurityAssistant"
    """

    _registry: Dict[str, Type[VerticalBase]] = {}
    _external_discovered: bool = False
    ENTRY_POINT_GROUP: str = "victor.verticals"

    @classmethod
    def register(cls, vertical: Type[VerticalBase]) -> None:
        """Register a vertical.

        Args:
            vertical: Vertical class to register.

        Raises:
            ValueError: If vertical has no name.
        """
        if not vertical.name:
            raise ValueError(f"Vertical {vertical.__name__} has no name defined")
        cls._registry[vertical.name] = vertical

    @classmethod
    def unregister(cls, name: str) -> None:
        """Unregister a vertical.

        Args:
            name: Vertical name to unregister.
        """
        if name in cls._registry:
            del cls._registry[name]

    @classmethod
    def get(cls, name: str) -> Optional[Type[VerticalBase]]:
        """Get a vertical by name.

        Args:
            name: Vertical name.

        Returns:
            Vertical class or None if not found.
        """
        return cls._registry.get(name)

    @classmethod
    def list_all(cls) -> List[tuple[str, Type[VerticalBase]]]:
        """List all registered verticals.

        Returns:
            List of (name, vertical_class) tuples.
        """
        return list(cls._registry.items())

    @classmethod
    def list_names(cls) -> List[str]:
        """List all registered vertical names.

        Returns:
            List of vertical names.
        """
        return list(cls._registry.keys())

    @classmethod
    def clear(cls, *, reregister_builtins: bool = True) -> None:
        """Clear all registered verticals (for testing).

        Args:
            reregister_builtins: If True (default), re-register built-in verticals
                after clearing. This prevents test pollution where clearing in one
                test affects other tests that expect built-ins to be available.
        """
        cls._registry.clear()
        cls._external_discovered = False

        if reregister_builtins:
            # Re-register built-in verticals to prevent test pollution
            from victor.core.verticals import _register_builtin_verticals

            _register_builtin_verticals()

    @classmethod
    def discover_external_verticals(cls) -> Dict[str, Type[VerticalBase]]:
        """Discover and register external verticals from entry points.

        Scans installed packages for the 'victor.verticals' entry point group
        and registers any valid vertical classes found. External verticals must:
        - Inherit from VerticalBase
        - Have a non-empty 'name' attribute

        Returns:
            Dictionary of newly discovered vertical names to their classes.

        Example entry point in external package's pyproject.toml:
            [project.entry-points."victor.verticals"]
            security = "victor_security:SecurityAssistant"

        This would load SecurityAssistant from the victor_security package
        and register it if it's a valid VerticalBase subclass.
        """
        import logging
        from importlib.metadata import entry_points

        logger = logging.getLogger(__name__)
        discovered: Dict[str, Type[VerticalBase]] = {}

        # Avoid re-discovery on repeated calls
        if cls._external_discovered:
            return discovered

        try:
            # Python 3.10+ API: entry_points() returns a SelectableGroups object
            # Use group parameter for filtering
            eps = entry_points(group=cls.ENTRY_POINT_GROUP)
        except TypeError:
            # Fallback for older Python versions (shouldn't happen with Python 3.10+)
            all_eps = entry_points()
            eps = all_eps.get(cls.ENTRY_POINT_GROUP, [])

        for ep in eps:
            try:
                # Load the entry point (imports the module and gets the object)
                vertical_class = ep.load()

                # Validate that it's a proper VerticalBase subclass
                if not cls._validate_external_vertical(vertical_class, ep.name):
                    continue

                # Check for name conflicts with existing verticals
                if vertical_class.name in cls._registry:
                    existing = cls._registry[vertical_class.name]
                    logger.warning(
                        f"External vertical '{ep.name}' has name '{vertical_class.name}' "
                        f"which conflicts with existing vertical {existing.__name__}. "
                        f"Skipping registration."
                    )
                    continue

                # Register the vertical
                cls.register(vertical_class)
                discovered[vertical_class.name] = vertical_class
                logger.info(
                    f"Discovered external vertical: {vertical_class.name} " f"(from {ep.value})"
                )

            except Exception as e:
                # Log the error but continue with other entry points
                logger.warning(
                    f"Failed to load external vertical '{ep.name}' from "
                    f"entry point '{ep.value}': {e}"
                )
                continue

        cls._external_discovered = True

        if discovered:
            logger.info(
                f"Discovered {len(discovered)} external vertical(s): "
                f"{', '.join(discovered.keys())}"
            )

        return discovered

    @classmethod
    def _validate_external_vertical(
        cls,
        vertical_class: Any,
        entry_point_name: str,
    ) -> bool:
        """Validate that an external vertical class is properly implemented.

        Args:
            vertical_class: The class loaded from the entry point.
            entry_point_name: Name of the entry point (for error messages).

        Returns:
            True if the vertical is valid, False otherwise.
        """
        import logging

        logger = logging.getLogger(__name__)

        # Check if it's a class
        if not isinstance(vertical_class, type):
            logger.warning(
                f"External vertical '{entry_point_name}' is not a class "
                f"(got {type(vertical_class).__name__}). Skipping."
            )
            return False

        # Check if it inherits from VerticalBase
        if not issubclass(vertical_class, VerticalBase):
            logger.warning(
                f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                f"does not inherit from VerticalBase. Skipping."
            )
            return False

        # Check if it has a name defined
        if not getattr(vertical_class, "name", None):
            logger.warning(
                f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                f"has no 'name' attribute defined. Skipping."
            )
            return False

        # Check if abstract methods are implemented
        # VerticalBase requires get_tools() and get_system_prompt()
        try:
            # Try to call the abstract methods to ensure they're implemented
            # These are classmethods so we can call them on the class
            tools = vertical_class.get_tools()
            if not isinstance(tools, list):
                logger.warning(
                    f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                    f"get_tools() must return a list. Skipping."
                )
                return False

            prompt = vertical_class.get_system_prompt()
            if not isinstance(prompt, str):
                logger.warning(
                    f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                    f"get_system_prompt() must return a string. Skipping."
                )
                return False
        except NotImplementedError:
            logger.warning(
                f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                f"has unimplemented abstract methods. Skipping."
            )
            return False
        except Exception as e:
            logger.warning(
                f"External vertical '{entry_point_name}' ({vertical_class.__name__}) "
                f"failed validation: {e}. Skipping."
            )
            return False

        return True

    @classmethod
    def reset_discovery(cls) -> None:
        """Reset the external discovery flag (for testing).

        This allows discover_external_verticals() to run again.
        """
        cls._external_discovered = False
