# Copyright 2025 Vijaykumar Singh <singhvjd@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests for Tool Capability System.

Tests the tool capability grouping and selection functionality for
composing tool sets based on functional capabilities.

Phase 2, Work Stream 2.2: Tool Capability Groups
"""

import pytest

from victor.tools.capabilities.system import (
    ToolCapability,
    CapabilityDefinition,
    CapabilityRegistry,
    CapabilitySelector,
)
from victor.tools.capabilities.definitions import BUILTIN_CAPABILITIES


# =============================================================================
# Test ToolCapability Enum
# =============================================================================


class TestToolCapability:
    """Tests for ToolCapability enum."""

    def test_has_file_read_capability(self):
        """Test FILE_READ capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_file_write_capability(self):
        """Test FILE_WRITE capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_web_search_capability(self):
        """Test WEB_SEARCH capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_code_analysis_capability(self):
        """Test CODE_ANALYSIS capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_version_control_capability(self):
        """Test VERSION_CONTROL capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_database_capability(self):
        """Test DATABASE capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_docker_capability(self):
        """Test DOCKER capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_ci_cd_capability(self):
        """Test CI_CD capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_documentation_capability(self):
        """Test DOCUMENTATION capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_testing_capability(self):
        """Test TESTING capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_code_search_capability(self):
        """Test CODE_SEARCH capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_bash_capability(self):
        """Test BASH capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_file_management_capability(self):
        """Test FILE_MANAGEMENT capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_browser_capability(self):
        """Test BROWSER capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_code_intelligence_capability(self):
        """Test CODE_INTELLIGENCE capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_cache_capability(self):
        """Test CACHE capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_batch_capability(self):
        """Test BATCH capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_audit_capability(self):
        """Test AUDIT capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_code_review_capability(self):
        """Test CODE_REVIEW capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_dependency_capability(self):
        """Test DEPENDENCY capability exists."""
        assert ToolCapability.\1.value == "\2"

    def test_has_at_least_20_capabilities(self):
        """Test that at least 20 capabilities are defined."""
        # Count unique capability values
        capabilities = [cap.value for cap in ToolCapability]
        unique_caps = set(capabilities)
        assert len(unique_caps) >= 20


# =============================================================================
# Test CapabilityDefinition
# =============================================================================


class TestCapabilityDefinition:
    """Tests for CapabilityDefinition dataclass."""

    def test_create_capability_definition(self):
        """Test creating a capability definition."""
        definition = CapabilityDefinition(
            name=ToolCapability.FILE_READ,
            description="Read files from filesystem",
            tools=["read", "ls"],
            dependencies=[],
            conflicts=[],
        )

        assert definition.name == ToolCapability.FILE_READ
        assert definition.description == "Read files from filesystem"
        assert definition.tools == ["read", "ls"]
        assert definition.dependencies == []
        assert definition.conflicts == []

    def test_create_capability_with_dependencies(self):
        """Test creating capability with dependencies."""
        definition = CapabilityDefinition(
            name=ToolCapability.FILE_WRITE,
            description="Write files to filesystem",
            tools=["write", "edit"],
            dependencies=[ToolCapability.FILE_READ],
            conflicts=[],
        )

        assert definition.dependencies == [ToolCapability.FILE_READ]

    def test_create_capability_with_conflicts(self):
        """Test creating capability with conflicts."""
        # Mock scenario: testing conflict system works
        # In practice, conflicts might be for things like FILE_WRITE vs READ_ONLY_MODE
        # but we'll test the mechanism with an example
        definition = CapabilityDefinition(
            name=ToolCapability.FILE_WRITE,
            description="Write files to filesystem",
            tools=["write"],
            dependencies=[],
            conflicts=[ToolCapability.FILE_MANAGEMENT],  # Example conflict
        )

        assert ToolCapability.FILE_MANAGEMENT in definition.conflicts


# =============================================================================
# Test CapabilityRegistry
# =============================================================================


class TestCapabilityRegistry:
    """Tests for CapabilityRegistry."""

    @pytest.fixture
    def registry(self):
        """Create empty registry."""
        return CapabilityRegistry()

    @pytest.fixture
    def registry_with_capabilities(self):
        """Create registry with sample capabilities."""
        registry = CapabilityRegistry()

        # Register FILE_READ
        registry.register_capability(
            CapabilityDefinition(
                name=ToolCapability.FILE_READ,
                description="Read files",
                tools=["read", "ls", "cat"],
                dependencies=[],
                conflicts=[],
            )
        )

        # Register FILE_WRITE (depends on FILE_READ)
        registry.register_capability(
            CapabilityDefinition(
                name=ToolCapability.FILE_WRITE,
                description="Write files",
                tools=["write", "edit"],
                dependencies=[ToolCapability.FILE_READ],
                conflicts=[],
            )
        )

        # Register CODE_ANALYSIS (independent)
        registry.register_capability(
            CapabilityDefinition(
                name=ToolCapability.CODE_ANALYSIS,
                description="Analyze code",
                tools=["code_review", "code_intelligence"],
                dependencies=[],
                conflicts=[],
            )
        )

        return registry

    def test_register_capability(self, registry):
        """Test registering a capability."""
        definition = CapabilityDefinition(
            name=ToolCapability.FILE_READ,
            description="Read files",
            tools=["read"],
            dependencies=[],
            conflicts=[],
        )

        registry.register_capability(definition)

        # Verify it's registered
        tools = registry.get_tools_for_capability(ToolCapability.FILE_READ)
        assert tools == {"read"}

    def test_register_duplicate_capability_raises(self, registry):
        """Test that registering duplicate capability raises error."""
        definition = CapabilityDefinition(
            name=ToolCapability.FILE_READ,
            description="Read files",
            tools=["read"],
            dependencies=[],
            conflicts=[],
        )

        registry.register_capability(definition)

        # Register again - should raise
        with pytest.raises(ValueError, match="already registered"):
            registry.register_capability(definition)

    def test_get_tools_for_capability(self, registry_with_capabilities):
        """Test getting tools for a capability."""
        tools = registry_with_capabilities.get_tools_for_capability(
            ToolCapability.FILE_READ
        )

        assert tools == {"read", "ls", "cat"}

    def test_get_tools_with_dependencies(self, registry_with_capabilities):
        """Test getting tools including dependencies."""
        # FILE_WRITE depends on FILE_READ
        tools = registry_with_capabilities.get_tools_for_capability(
            ToolCapability.FILE_WRITE, include_dependencies=True
        )

        # Should include both FILE_WRITE and FILE_READ tools
        assert "write" in tools
        assert "edit" in tools
        assert "read" in tools
        assert "ls" in tools
        assert "cat" in tools

    def test_get_tools_without_dependencies(self, registry_with_capabilities):
        """Test getting tools without dependencies."""
        tools = registry_with_capabilities.get_tools_for_capability(
            ToolCapability.FILE_WRITE, include_dependencies=False
        )

        # Should only include FILE_WRITE tools
        assert tools == {"write", "edit"}

    def test_check_conflicts_no_conflicts(self, registry_with_capabilities):
        """Test conflict check with no conflicts."""
        capabilities = [
            ToolCapability.FILE_READ,
            ToolCapability.CODE_ANALYSIS,
        ]

        conflicts = registry_with_capabilities.check_conflicts(capabilities)

        assert conflicts == []

    def test_check_conflicts_with_conflicts(self, registry):
        """Test conflict check with conflicting capabilities."""
        # Register capabilities with conflicts
        registry.register_capability(
            CapabilityDefinition(
                name=ToolCapability.FILE_WRITE,
                description="Write files",
                tools=["write"],
                dependencies=[],
                conflicts=[ToolCapability.FILE_MANAGEMENT],
            )
        )

        registry.register_capability(
            CapabilityDefinition(
                name=ToolCapability.FILE_MANAGEMENT,
                description="File management operations",
                tools=["file_editor"],
                dependencies=[],
                conflicts=[ToolCapability.FILE_WRITE],
            )
        )

        capabilities = [
            ToolCapability.FILE_WRITE,
            ToolCapability.FILE_MANAGEMENT,
        ]

        conflicts = registry.check_conflicts(capabilities)

        # Should return the conflicting pair
        assert len(conflicts) == 1
        assert conflicts[0] == (ToolCapability.FILE_WRITE, ToolCapability.FILE_MANAGEMENT)

    def test_resolve_dependencies(self, registry_with_capabilities):
        """Test resolving capability dependencies."""
        # Request FILE_WRITE which depends on FILE_READ
        capabilities = [ToolCapability.FILE_WRITE]

        resolved = registry_with_capabilities.resolve_dependencies(capabilities)

        # Should include both FILE_WRITE and FILE_READ
        assert ToolCapability.FILE_WRITE in resolved
        assert ToolCapability.FILE_READ in resolved

    def test_resolve_dependencies_already_included(self, registry_with_capabilities):
        """Test resolving dependencies when some are already included."""
        capabilities = [
            ToolCapability.FILE_READ,
            ToolCapability.FILE_WRITE,
        ]

        resolved = registry_with_capabilities.resolve_dependencies(capabilities)

        # Should include both, no duplicates
        assert ToolCapability.FILE_READ in resolved
        assert ToolCapability.FILE_WRITE in resolved
        assert len(resolved) == 2

    def test_resolve_dependencies_no_dependencies(self, registry_with_capabilities):
        """Test resolving capabilities with no dependencies."""
        capabilities = [ToolCapability.CODE_ANALYSIS]

        resolved = registry_with_capabilities.resolve_dependencies(capabilities)

        # Should just return the original capability
        assert resolved == [ToolCapability.CODE_ANALYSIS]


# =============================================================================
# Test CapabilitySelector
# =============================================================================


class TestCapabilitySelector:
    """Tests for CapabilitySelector."""

    @pytest.fixture
    def selector(self):
        """Create selector with test registry."""
        registry = CapabilityRegistry()

        # Register test capabilities
        registry.register_capability(
            CapabilityDefinition(
                name=ToolCapability.FILE_READ,
                description="Read files",
                tools=["read", "ls", "cat"],
                dependencies=[],
                conflicts=[],
            )
        )

        registry.register_capability(
            CapabilityDefinition(
                name=ToolCapability.FILE_WRITE,
                description="Write files",
                tools=["write", "edit"],
                dependencies=[ToolCapability.FILE_READ],
                conflicts=[],
            )
        )

        registry.register_capability(
            CapabilityDefinition(
                name=ToolCapability.CODE_ANALYSIS,
                description="Analyze code",
                tools=["code_review"],
                dependencies=[],
                conflicts=[],
            )
        )

        return CapabilitySelector(registry)

    def test_select_tools_single_capability(self, selector):
        """Test selecting tools for single capability."""
        tools = selector.select_tools(
            required_capabilities=[ToolCapability.FILE_READ],
            excluded_tools=None,
        )

        assert tools == ["read", "ls", "cat"]

    def test_select_tools_multiple_capabilities(self, selector):
        """Test selecting tools for multiple capabilities."""
        tools = selector.select_tools(
            required_capabilities=[
                ToolCapability.FILE_READ,
                ToolCapability.CODE_ANALYSIS,
            ],
            excluded_tools=None,
        )

        # Should include tools from both capabilities
        assert "read" in tools
        assert "ls" in tools
        assert "cat" in tools
        assert "code_review" in tools

    def test_select_tools_with_dependencies(self, selector):
        """Test selecting tools includes dependency tools."""
        tools = selector.select_tools(
            required_capabilities=[ToolCapability.FILE_WRITE],
            excluded_tools=None,
        )

        # FILE_WRITE depends on FILE_READ, so should include both
        assert "write" in tools
        assert "edit" in tools
        assert "read" in tools
        assert "ls" in tools
        assert "cat" in tools

    def test_select_tools_with_exclusions(self, selector):
        """Test selecting tools with exclusions."""
        tools = selector.select_tools(
            required_capabilities=[ToolCapability.FILE_READ],
            excluded_tools={"ls"},  # Exclude ls tool
        )

        # Should include read and cat, but not ls
        assert "read" in tools
        assert "cat" in tools
        assert "ls" not in tools

    def test_select_tools_empty_capabilities(self, selector):
        """Test selecting tools with no capabilities returns empty list."""
        tools = selector.select_tools(
            required_capabilities=[],
            excluded_tools=None,
        )

        assert tools == []

    def test_select_tools_duplicate_tools_removed(self, selector):
        """Test that duplicate tools are removed."""
        # Both FILE_READ and FILE_WRITE include "read" (via dependency)
        tools = selector.select_tools(
            required_capabilities=[
                ToolCapability.FILE_READ,
                ToolCapability.FILE_WRITE,
            ],
            excluded_tools=None,
        )

        # Check no duplicates
        assert len(tools) == len(set(tools))


# =============================================================================
# Test Built-in Capabilities
# =============================================================================


class TestBuiltinCapabilities:
    """Tests for built-in capability definitions."""

    def test_builtin_capabilities_is_list(self):
        """Test that BUILTIN_CAPABILITIES is a list."""
        assert isinstance(BUILTIN_CAPABILITIES, list)

    def test_builtin_capabilities_not_empty(self):
        """Test that BUILTIN_CAPABILITIES is not empty."""
        assert len(BUILTIN_CAPABILITIES) > 0

    def test_builtin_capabilities_are_definitions(self):
        """Test that all builtin capabilities are CapabilityDefinition instances."""
        for cap in BUILTIN_CAPABILITIES:
            assert isinstance(cap, CapabilityDefinition)

    def test_builtin_capabilities_have_unique_names(self):
        """Test that builtin capabilities have unique names."""
        names = [cap.name for cap in BUILTIN_CAPABILITIES]
        assert len(names) == len(set(names))

    def test_builtin_capabilities_file_read_exists(self):
        """Test that FILE_READ capability is defined."""
        names = [cap.name for cap in BUILTIN_CAPABILITIES]
        assert ToolCapability.FILE_READ in names

    def test_builtin_capabilities_file_write_exists(self):
        """Test that FILE_WRITE capability is defined."""
        names = [cap.name for cap in BUILTIN_CAPABILITIES]
        assert ToolCapability.FILE_WRITE in names

    def test_builtin_capabilities_web_search_exists(self):
        """Test that WEB_SEARCH capability is defined."""
        names = [cap.name for cap in BUILTIN_CAPABILITIES]
        assert ToolCapability.WEB_SEARCH in names

    def test_builtin_capabilities_file_write_depends_on_read(self):
        """Test that FILE_WRITE depends on FILE_READ."""
        file_write_cap = None
        for cap in BUILTIN_CAPABILITIES:
            if cap.name == ToolCapability.FILE_WRITE:
                file_write_cap = cap
                break

        assert file_write_cap is not None
        assert ToolCapability.FILE_READ in file_write_cap.dependencies

    def test_builtin_capabilities_have_tools(self):
        """Test that all builtin capabilities have at least one tool."""
        for cap in BUILTIN_CAPABILITIES:
            assert len(cap.tools) > 0, f"{cap.name} has no tools"

    def test_builtin_capabilities_have_descriptions(self):
        """Test that all builtin capabilities have descriptions."""
        for cap in BUILTIN_CAPABILITIES:
            assert len(cap.description) > 0, f"{cap.name} has no description"
