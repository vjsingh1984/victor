# Copyright 2025 Vijaykumar Singh <singhvjd@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Demo: Docker Compose setup for multiple MCP servers with Victor.

This example shows how to set up and manage multiple MCP servers using
Docker Compose, and how to connect them all to Victor using MCPRegistry.

This approach is ideal for:
- Production deployments with multiple MCP services
- Development environments with consistent MCP server setup
- Teams sharing MCP server configurations
- CI/CD pipelines requiring reproducible MCP environments

MCP Servers in this demo:
- AWS Documentation Server: Search AWS docs
- Playwright Server: Browser automation and screenshots
- Filesystem Server: File operations (optional)
- Memory Server: Key-value storage (optional)

Prerequisites:
-------------
1. Docker and Docker Compose installed
2. docker compose version 2.x (v2 syntax)

Usage:
------
    # Generate docker-compose.yaml and start services
    python examples/mcp_docker_compose_demo.py --setup

    # Run the demo (services must be running)
    python examples/mcp_docker_compose_demo.py

    # Stop and clean up services
    python examples/mcp_docker_compose_demo.py --cleanup

    # Show configuration examples only
    python examples/mcp_docker_compose_demo.py --examples

Docker Compose Commands:
-----------------------
    # Start all MCP services
    docker compose -f mcp-servers.yaml up -d

    # View logs
    docker compose -f mcp-servers.yaml logs -f

    # Stop services
    docker compose -f mcp-servers.yaml down

    # Rebuild and restart
    docker compose -f mcp-servers.yaml up -d --build

References:
-----------
    - Docker Compose: https://docs.docker.com/compose/
    - AWS MCP: https://github.com/awslabs/mcp
    - Playwright MCP: https://github.com/anthropics/mcp-server-playwright
    - MCP Protocol: https://modelcontextprotocol.io
"""

import argparse
import asyncio
import logging
import os
import shutil
import subprocess
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional

# Set up logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger(__name__)

# Docker Compose configuration for MCP servers
DOCKER_COMPOSE_CONFIG = """
# MCP Servers Docker Compose Configuration
# Generated by Victor MCP Docker Compose Demo
#
# Usage:
#   docker compose -f mcp-servers.yaml up -d
#   docker compose -f mcp-servers.yaml logs -f
#   docker compose -f mcp-servers.yaml down

version: '3.8'

services:
  # AWS Documentation MCP Server
  # Provides tools for searching and retrieving AWS documentation
  aws-documentation:
    image: public.ecr.aws/aws-mcp/aws-documentation-mcp-server:latest
    container_name: mcp-aws-docs
    stdin_open: true
    tty: true
    restart: unless-stopped
    networks:
      - mcp-network
    healthcheck:
      test: ["CMD", "echo", "healthy"]
      interval: 30s
      timeout: 10s
      retries: 3

  # AWS CDK MCP Server
  # Provides tools for generating and validating AWS CDK code
  # Requires AWS credentials to be set
  aws-cdk:
    image: public.ecr.aws/aws-mcp/aws-cdk-mcp-server:latest
    container_name: mcp-aws-cdk
    stdin_open: true
    tty: true
    restart: unless-stopped
    environment:
      - AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID:-}
      - AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY:-}
      - AWS_REGION=${AWS_REGION:-us-east-1}
    networks:
      - mcp-network
    profiles:
      - aws-full  # Only start with --profile aws-full

  # Playwright MCP Server
  # Provides browser automation, screenshots, and web scraping
  playwright:
    image: anthropic/mcp-server-playwright:latest
    container_name: mcp-playwright
    stdin_open: true
    tty: true
    restart: unless-stopped
    volumes:
      - playwright-screenshots:/screenshots
      - playwright-downloads:/downloads
    environment:
      - PLAYWRIGHT_BROWSERS_PATH=/ms-playwright
    networks:
      - mcp-network
    healthcheck:
      test: ["CMD", "echo", "healthy"]
      interval: 30s
      timeout: 10s
      retries: 3

  # Filesystem MCP Server (optional)
  # Provides file system operations with configurable root
  filesystem:
    image: modelcontextprotocol/mcp-server-filesystem:latest
    container_name: mcp-filesystem
    stdin_open: true
    tty: true
    restart: unless-stopped
    volumes:
      - ${MCP_WORKSPACE:-./workspace}:/workspace:rw
    environment:
      - MCP_ROOT=/workspace
    networks:
      - mcp-network
    profiles:
      - extended  # Only start with --profile extended

  # Memory MCP Server (optional)
  # Provides key-value storage for agents
  memory:
    image: modelcontextprotocol/mcp-server-memory:latest
    container_name: mcp-memory
    stdin_open: true
    tty: true
    restart: unless-stopped
    volumes:
      - memory-data:/data
    networks:
      - mcp-network
    profiles:
      - extended  # Only start with --profile extended

networks:
  mcp-network:
    driver: bridge
    name: victor-mcp-network

volumes:
  playwright-screenshots:
    name: mcp-playwright-screenshots
  playwright-downloads:
    name: mcp-playwright-downloads
  memory-data:
    name: mcp-memory-data
"""

# Victor MCP configuration template
VICTOR_MCP_CONFIG = """
# Victor MCP Configuration
# Place this file at ~/.victor/mcp.yaml or .victor/mcp.yaml in your project
#
# This configuration connects Victor to MCP servers running via Docker Compose.

health_check_enabled: true
default_health_interval: 60

servers:
  # AWS Documentation MCP Server
  - name: aws-documentation
    command:
      - docker
      - exec
      - -i
      - mcp-aws-docs
      - /app/server
    description: AWS Documentation search and retrieval
    tags:
      - aws
      - documentation
      - docker
    auto_connect: true
    health_check_interval: 60
    max_retries: 3

  # Playwright Browser Automation
  - name: playwright
    command:
      - docker
      - exec
      - -i
      - mcp-playwright
      - node
      - /app/dist/index.js
    description: Browser automation and web scraping
    tags:
      - browser
      - automation
      - screenshot
      - docker
    auto_connect: true
    health_check_interval: 60

  # AWS CDK (optional, requires AWS credentials)
  - name: aws-cdk
    command:
      - docker
      - exec
      - -i
      - mcp-aws-cdk
      - /app/server
    description: AWS CDK code generation
    tags:
      - aws
      - cdk
      - infrastructure
      - docker
    auto_connect: false  # Manual connect since it requires credentials
    enabled: ${AWS_ACCESS_KEY_ID:+true}  # Only enable if AWS credentials are set

  # Filesystem Server (if using extended profile)
  - name: filesystem
    command:
      - docker
      - exec
      - -i
      - mcp-filesystem
      - /app/server
    description: File system operations
    tags:
      - filesystem
      - docker
    auto_connect: false
    enabled: false  # Enable manually if using extended profile

  # Memory Server (if using extended profile)
  - name: memory
    command:
      - docker
      - exec
      - -i
      - mcp-memory
      - /app/server
    description: Key-value storage for agents
    tags:
      - memory
      - storage
      - docker
    auto_connect: false
    enabled: false  # Enable manually if using extended profile
"""


def check_docker_compose_available() -> bool:
    """Check if Docker Compose is available."""
    if not shutil.which("docker"):
        return False
    try:
        result = subprocess.run(
            ["docker", "compose", "version"],
            capture_output=True,
            text=True,
            timeout=10,
        )
        return result.returncode == 0
    except Exception:
        return False


def check_docker_running() -> bool:
    """Check if Docker daemon is running."""
    try:
        result = subprocess.run(
            ["docker", "info"],
            capture_output=True,
            text=True,
            timeout=10,
        )
        return result.returncode == 0
    except Exception:
        return False


def setup_docker_compose(output_dir: Path = None) -> Path:
    """Generate docker-compose.yaml for MCP servers.

    Args:
        output_dir: Directory to write the file (default: current directory)

    Returns:
        Path to the generated file
    """
    if output_dir is None:
        output_dir = Path.cwd()

    compose_path = output_dir / "mcp-servers.yaml"
    compose_path.write_text(DOCKER_COMPOSE_CONFIG)

    print(f"Generated Docker Compose config: {compose_path}")
    return compose_path


def setup_victor_config(output_dir: Path = None) -> Path:
    """Generate Victor MCP configuration.

    Args:
        output_dir: Directory to write the file (default: ~/.victor/)

    Returns:
        Path to the generated file
    """
    if output_dir is None:
        output_dir = Path.home() / ".victor"

    output_dir.mkdir(parents=True, exist_ok=True)
    config_path = output_dir / "mcp.yaml"

    # Don't overwrite existing config
    if config_path.exists():
        backup_path = config_path.with_suffix(".yaml.bak")
        print(f"Backing up existing config to: {backup_path}")
        config_path.rename(backup_path)

    config_path.write_text(VICTOR_MCP_CONFIG)
    print(f"Generated Victor MCP config: {config_path}")
    return config_path


def start_docker_compose(compose_path: Path, profile: str = None) -> bool:
    """Start MCP servers using Docker Compose.

    Args:
        compose_path: Path to docker-compose.yaml
        profile: Optional profile to use (e.g., 'extended', 'aws-full')

    Returns:
        True if successful
    """
    cmd = ["docker", "compose", "-f", str(compose_path), "up", "-d"]
    if profile:
        cmd.extend(["--profile", profile])

    print(f"Starting MCP servers: {' '.join(cmd)}")
    result = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode != 0:
        print(f"Error starting containers:\n{result.stderr}")
        return False

    print("MCP servers started successfully!")
    return True


def stop_docker_compose(compose_path: Path) -> bool:
    """Stop MCP servers.

    Args:
        compose_path: Path to docker-compose.yaml

    Returns:
        True if successful
    """
    cmd = ["docker", "compose", "-f", str(compose_path), "down"]
    print(f"Stopping MCP servers: {' '.join(cmd)}")
    result = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode != 0:
        print(f"Error stopping containers:\n{result.stderr}")
        return False

    print("MCP servers stopped.")
    return True


def get_container_status() -> Dict[str, str]:
    """Get status of MCP containers.

    Returns:
        Dict mapping container name to status
    """
    try:
        result = subprocess.run(
            ["docker", "ps", "-a", "--filter", "name=mcp-", "--format", "{{.Names}}:{{.Status}}"],
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode != 0:
            return {}

        status = {}
        for line in result.stdout.strip().split("\n"):
            if ":" in line:
                name, state = line.split(":", 1)
                status[name] = state
        return status
    except Exception as e:
        logger.error(f"Error getting container status: {e}")
        return {}


async def demo_multi_server_registry():
    """Demo using multiple MCP servers via MCPRegistry."""
    print("=" * 70)
    print("Multi-Server MCP Demo with Docker Compose")
    print("=" * 70)

    if not check_docker_running():
        print("\nError: Docker is not running.")
        print("Please start Docker and try again.")
        return

    # Check container status
    print("\n1. Checking MCP container status...")
    print("-" * 70)
    status = get_container_status()

    if not status:
        print("   No MCP containers found.")
        print("   Run with --setup first to create and start containers.")
        return

    for name, state in status.items():
        running = "Up" in state
        icon = "[OK]" if running else "[--]"
        print(f"   {icon} {name}: {state}")

    # Import Victor MCP components
    try:
        from victor.integrations.mcp import MCPRegistry, MCPServerConfig
    except ImportError:
        print("\nError: Victor MCP integration not available.")
        print("Please install Victor: pip install -e '.[dev]'")
        return

    # Create registry
    print("\n2. Setting up MCPRegistry...")
    print("-" * 70)

    registry = MCPRegistry(
        health_check_enabled=False,  # Disable for demo
    )

    # Define servers based on running containers
    servers = []

    if "mcp-aws-docs" in status and "Up" in status.get("mcp-aws-docs", ""):
        servers.append(
            MCPServerConfig(
                name="aws-documentation",
                command=["docker", "exec", "-i", "mcp-aws-docs", "/app/server"],
                description="AWS Documentation MCP Server",
                tags=["aws", "documentation", "docker"],
            )
        )

    if "mcp-playwright" in status and "Up" in status.get("mcp-playwright", ""):
        servers.append(
            MCPServerConfig(
                name="playwright",
                command=["docker", "exec", "-i", "mcp-playwright", "node", "/app/dist/index.js"],
                description="Playwright Browser Automation",
                tags=["browser", "automation", "docker"],
            )
        )

    if "mcp-aws-cdk" in status and "Up" in status.get("mcp-aws-cdk", ""):
        servers.append(
            MCPServerConfig(
                name="aws-cdk",
                command=["docker", "exec", "-i", "mcp-aws-cdk", "/app/server"],
                description="AWS CDK MCP Server",
                tags=["aws", "cdk", "docker"],
                auto_connect=False,
            )
        )

    if not servers:
        print("   No running MCP containers to connect to.")
        print("   Start containers with: docker compose -f mcp-servers.yaml up -d")
        return

    for server in servers:
        registry.register_server(server)
        print(f"   Registered: {server.name}")

    # Connect to all servers
    print("\n3. Connecting to MCP servers...")
    print("-" * 70)

    results = await registry.connect_all()
    for name, success in results.items():
        icon = "[OK]" if success else "[--]"
        print(f"   {icon} {name}: {'Connected' if success else 'Failed'}")

    # Show registry status
    print("\n4. Registry status...")
    print("-" * 70)
    reg_status = registry.get_registry_status()
    print(f"   Total servers: {reg_status['total_servers']}")
    print(f"   Connected: {reg_status['connected_servers']}")
    print(f"   Total tools: {reg_status['total_tools']}")
    print(f"   Total resources: {reg_status['total_resources']}")

    # List all available tools
    print("\n5. Available tools across all servers...")
    print("-" * 70)
    all_tools = registry.get_all_tools()
    if all_tools:
        # Group by server
        for server_name in registry.list_servers():
            server_tools = registry.get_tools_by_server(server_name)
            if server_tools:
                print(f"\n   [{server_name}]")
                for tool in server_tools[:5]:  # Show first 5 per server
                    desc = tool.description[:50] + "..." if len(tool.description) > 50 else tool.description
                    print(f"   - {tool.name}: {desc}")
                if len(server_tools) > 5:
                    print(f"   ... and {len(server_tools) - 5} more tools")
    else:
        print("   No tools available.")

    # Demo: Call tools from different servers
    print("\n6. Demo: Using tools from multiple servers...")
    print("-" * 70)

    # Try AWS documentation search
    if "aws-documentation" in results and results["aws-documentation"]:
        print("\n   [AWS Documentation]")
        aws_tools = registry.get_tools_by_server("aws-documentation")
        search_tool = next((t for t in aws_tools if "search" in t.name.lower()), None)
        if search_tool:
            print(f"   Calling: {search_tool.name}")
            result = await registry.call_tool(search_tool.name, query="Lambda")
            if result.success:
                print(f"   Result preview: {str(result.result)[:100]}...")
            else:
                print(f"   Error: {result.error}")

    # Try Playwright navigation
    if "playwright" in results and results["playwright"]:
        print("\n   [Playwright]")
        pw_tools = registry.get_tools_by_server("playwright")
        navigate_tool = next((t for t in pw_tools if "navigate" in t.name.lower()), None)
        if navigate_tool:
            print(f"   Calling: {navigate_tool.name}")
            result = await registry.call_tool(navigate_tool.name, url="https://example.com")
            if result.success:
                print("   Navigation successful!")
            else:
                print(f"   Error: {result.error}")

    # Clean up
    print("\n7. Cleaning up...")
    print("-" * 70)
    await registry.disconnect_all()
    print("   All servers disconnected.")


def show_integration_examples():
    """Show Docker Compose integration examples."""
    print("\n" + "=" * 70)
    print("Docker Compose MCP Integration Examples")
    print("=" * 70)

    print(
        """
1. Docker Compose File (mcp-servers.yaml)
-----------------------------------------
"""
    )
    print(DOCKER_COMPOSE_CONFIG[:1500] + "\n... (truncated)")

    print(
        """

2. Victor MCP Configuration (~/.victor/mcp.yaml)
------------------------------------------------
"""
    )
    print(VICTOR_MCP_CONFIG[:1200] + "\n... (truncated)")

    print(
        """

3. Quick Start Commands
-----------------------
# Generate configuration files
python examples/mcp_docker_compose_demo.py --setup

# Start MCP servers (basic)
docker compose -f mcp-servers.yaml up -d

# Start with extended services
docker compose -f mcp-servers.yaml --profile extended up -d

# Start with AWS CDK (requires credentials)
docker compose -f mcp-servers.yaml --profile aws-full up -d

# View logs
docker compose -f mcp-servers.yaml logs -f

# Check status
docker compose -f mcp-servers.yaml ps

# Stop all services
docker compose -f mcp-servers.yaml down

# Remove volumes too
docker compose -f mcp-servers.yaml down -v

4. Environment Variables
------------------------
# AWS credentials (for CDK server)
export AWS_ACCESS_KEY_ID=your-key
export AWS_SECRET_ACCESS_KEY=your-secret
export AWS_REGION=us-east-1

# Custom workspace for filesystem server
export MCP_WORKSPACE=/path/to/workspace

5. Programmatic Usage
---------------------
from victor.integrations.mcp import MCPRegistry, MCPServerConfig

# Create registry
registry = MCPRegistry()

# Register Docker-based servers
registry.register_server(MCPServerConfig(
    name="aws-docs",
    command=["docker", "exec", "-i", "mcp-aws-docs", "/app/server"],
    tags=["aws", "docker"],
))

registry.register_server(MCPServerConfig(
    name="playwright",
    command=["docker", "exec", "-i", "mcp-playwright", "node", "/app/dist/index.js"],
    tags=["browser", "docker"],
))

# Connect and use
async with registry:
    await registry.connect_all()

    # Search AWS docs
    result = await registry.call_tool("search_docs", query="S3")

    # Take screenshot
    await registry.call_tool("navigate", url="https://aws.amazon.com")
    await registry.call_tool("screenshot")

6. CI/CD Integration
--------------------
# .github/workflows/test.yml
jobs:
  test:
    runs-on: ubuntu-latest
    services:
      mcp-aws-docs:
        image: public.ecr.aws/aws-mcp/aws-documentation-mcp-server:latest
      mcp-playwright:
        image: anthropic/mcp-server-playwright:latest

    steps:
      - uses: actions/checkout@v3
      - name: Run tests with MCP
        run: |
          python -m pytest tests/integration/test_mcp.py

7. Kubernetes Deployment (Future)
---------------------------------
# For production, consider:
# - Running MCP servers as Kubernetes pods
# - Using service mesh for inter-service communication
# - Implementing proper health checks and scaling
# - Using secrets management for credentials
"""
    )


async def main():
    """Run Docker Compose MCP demo."""
    parser = argparse.ArgumentParser(
        description="Docker Compose MCP Server Demo",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python examples/mcp_docker_compose_demo.py --setup     # Generate configs and start
  python examples/mcp_docker_compose_demo.py             # Run demo (containers must be up)
  python examples/mcp_docker_compose_demo.py --cleanup   # Stop containers
  python examples/mcp_docker_compose_demo.py --examples  # Show integration examples
        """,
    )
    parser.add_argument(
        "--setup",
        action="store_true",
        help="Generate Docker Compose config and start services",
    )
    parser.add_argument(
        "--cleanup",
        action="store_true",
        help="Stop and remove Docker Compose services",
    )
    parser.add_argument(
        "--examples",
        action="store_true",
        help="Show integration examples and exit",
    )
    parser.add_argument(
        "--profile",
        choices=["basic", "extended", "aws-full"],
        default="basic",
        help="Docker Compose profile to use",
    )
    parser.add_argument(
        "--config-dir",
        type=Path,
        default=None,
        help="Directory for configuration files",
    )

    args = parser.parse_args()

    print("Docker Compose MCP Server Demo")
    print("=" * 70)
    print("\nThis demo shows how to manage multiple MCP servers with Docker Compose.")

    if args.examples:
        show_integration_examples()
        return

    # Check prerequisites
    if not check_docker_compose_available():
        print("\nError: Docker Compose is not available.")
        print("\nInstallation:")
        print("  - Docker Desktop includes Compose: https://www.docker.com/products/docker-desktop")
        print("  - Or install standalone: https://docs.docker.com/compose/install/")
        return

    compose_path = Path("mcp-servers.yaml")
    if args.config_dir:
        compose_path = args.config_dir / "mcp-servers.yaml"

    if args.setup:
        print("\n1. Generating configuration files...")
        print("-" * 70)
        compose_path = setup_docker_compose(args.config_dir or Path.cwd())
        setup_victor_config()

        print("\n2. Starting MCP servers...")
        print("-" * 70)
        profile = args.profile if args.profile != "basic" else None
        if not start_docker_compose(compose_path, profile):
            return

        print("\n3. Waiting for containers to be ready...")
        print("-" * 70)
        await asyncio.sleep(5)  # Give containers time to start

        status = get_container_status()
        for name, state in status.items():
            running = "Up" in state
            icon = "[OK]" if running else "[--]"
            print(f"   {icon} {name}: {state}")

        print("\nSetup complete! Run without --setup to test the MCP servers.")
        return

    if args.cleanup:
        print("\n1. Stopping MCP servers...")
        print("-" * 70)
        if compose_path.exists():
            stop_docker_compose(compose_path)
        else:
            print(f"   Config file not found: {compose_path}")
            print("   Trying to stop containers directly...")
            subprocess.run(["docker", "stop", "mcp-aws-docs", "mcp-playwright", "mcp-aws-cdk"], capture_output=True)

        print("\nCleanup complete!")
        return

    # Run the demo
    await demo_multi_server_registry()

    print("\n" + "=" * 70)
    print("Demo Complete!")
    print("=" * 70)
    print("\nNext steps:")
    print("  1. Customize mcp-servers.yaml for your needs")
    print("  2. Add to your project's docker-compose.yaml")
    print("  3. Configure Victor with ~/.victor/mcp.yaml")
    print("  4. Use MCP tools in your Victor workflows")


if __name__ == "__main__":
    asyncio.run(main())
